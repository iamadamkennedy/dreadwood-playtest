<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dreadwood Playtest</title>
    <style>
        body {
            background: #333;
            color: #fff;
            text-align: center;
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }
        h1 {
            font-size: 24px;
            margin: 20px 0;
        }
        #setup-screen, #game-screen {
            margin: 20px auto;
            max-width: 90%;
        }
        #setup-screen {
            display: block;
            background: #444;
            padding: 30px;
        }
        #game-screen {
            display: none;
            flex-direction: column;
            align-items: center;
        }
        #game-info {
            background: #444;
            padding: 10px;
            border: 1px solid #000;
            margin: 10px 0;
            width: 100%;
            max-width: 90%;
            box-sizing: border-box;
        }
        #actions, #special-actions {
            display: flex;
            flex-direction: row;
            justify-content: center;
            flex-wrap: wrap;
            margin: 10px 0;
            width: 100%;
            max-width: 90%;
        }
        .action-icon {
            margin: 5px;
            padding: 5px;
            background: #666;
            border: 1px solid #000;
            font-size: 30px;
            cursor: pointer;
        }
        .action-icon.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .action-separator {
            color: #fff;
            margin: 0 5px;
            font-size: 30px;
        }
        #grid-container {
            position: relative;
            margin: 10px;
            max-width: 90%;
        }
        #grid {
            display: block;
            background: #555;
            padding: 5px;
            border: 1px solid #000;
        }
        .cell {
            background: rgba(85, 85, 85, 0.8);
            border: 0.5px solid #000;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            cursor: pointer;
            position: relative;
            box-sizing: border-box;
        }
        .vampire { font-size: 16px; }
        .vampire.sheriff { background: #00f; }
        .vampire.vigilante { background: #333; }
        .vampire.outlaw { background: #f00; }
        .vampire.bounty-hunter { background: #0f0; }
        .bloodwell { background: #000; }
        .bloodwell::before { content: 'ü©∏'; font-size: 16px; }
        .bloodwell.sheriff { background: #000; color: #00f; }
        .bloodwell.vigilante { background: #000; color: #333; }
        .bloodwell.outlaw { background: #000; color: #f00; }
        .bloodwell.bounty-hunter { background: #000; color: #0f0; }
        .tombstone::before { content: 'ü™¶'; }
        .carcass::before { content: 'üíÄ'; }
        .grave-dust::before { content: 'üí©'; }
        .dynamite::before { content: 'üí•'; }
        .cursed { border: 2px solid #800080; }
        .selected { box-shadow: 0 0 5px 2px #ffff00; }
        .arrow {
            position: absolute;
            background: rgba(255, 255, 255, 0.5);
            font-size: 16px;
            cursor: pointer;
        }
        .arrow:hover {
            background: rgba(255, 255, 255, 0.8);
        }
        #class-info {
            display: block;
            background: #444;
            padding: 10px;
            border: 1px solid #000;
            margin: 10px;
            text-align: left;
            max-width: 300px;
        }
        #class-info h3 {
            margin: 0;
            font-size: 18px;
        }
        #class-info p, #class-info ul {
            color: #000;
            font-size: 14px;
            margin: 5px 0;
        }
        #class-info ul {
            list-style: none;
            padding: 0;
        }
        #class-info li {
            margin: 5px 0;
        }
        #class-info strong {
            color: #000;
        }
        #class-info .used {
            color: #888;
            cursor: default;
        }
        #class-info .active-ability {
            cursor: pointer;
        }
        #class-info .active-ability:hover {
            text-decoration: underline;
        }
        #controls {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            margin: 10px 0;
            width: 100%;
            max-width: 90%;
        }
        button {
            margin: 5px;
            padding: 10px 20px;
            background: #666;
            color: #fff;
            border: 1px solid #000;
            border-radius: 5px;
            cursor: pointer;
            font-size: 18px;
            text-transform: uppercase;
            touch-action: manipulation;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        select, input[type="text"] {
            padding: 5px;
            margin: 5px;
            background: #444;
            color: #fff;
            border: 1px solid #000;
            border-radius: 5px;
            font-size: 16px;
        }
        .class-selection {
            margin: 20px 0;
        }
        .class-selection button {
            margin: 2px;
            padding: 8px 12px;
            font-size: 16px;
            border: 2px solid #000;
            border-radius: 5px;
            cursor: pointer;
        }
        .class-selection button.sheriff { background: #00f; color: #fff; }
        .class-selection button.vigilante { background: #333; color: #fff; }
        .class-selection button.outlaw { background: #f00; color: #fff; }
        .class-selection button.bounty-hunter { background: #0f0; color: #fff; }
        .class-selection button.selected {
            outline: 2px solid #ffff00;
            box-shadow: 0 0 5px 2px #ffff00;
        }
        .class-info {
            padding: 15px;
            margin: 30px 0;
            text-align: left;
            color: #fff;
        }
        .class-name {
            font-size: 18px;
            margin: 0;
        }
        .class-description {
            font-size: 16px;
            margin: 5px 0;
        }
        .class-abilities {
            list-style: none;
            padding: 0;
            font-size: 16px;
        }
        .class-abilities li {
            margin: 5px 0;
        }
        .class-abilities strong {
            color: #fff;
        }
        .class-abilities h4 {
            font-size: 16px;
            font-weight: bold;
            margin-top: 10px;
            color: #fff;
        }
        .player-count-buttons {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        label {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 5px;
            display: block;
        }
        #elimination-message, #victory-message {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #444;
            padding: 20px;
            border: 1px solid #000;
            border-radius: 10px;
            font-size: 24px;
            z-index: 1000;
            text-align: center;
        }
        @media (max-width: 600px) {
            #grid {
                grid-template-columns: repeat(9, 40px);
            }
            .cell {
                width: 40px;
                height: 40px;
                font-size: 14px;
            }
            .vampire { font-size: 14px; }
            .bloodwell::before { font-size: 14px; }
            .arrow { font-size: 14px; }
            .action-icon { font-size: 24px; }
            #class-info {
                max-width: 100%;
                margin: 10px 0;
            }
            h1 { font-size: 20px; }
            #game-info, .class-description, .class-abilities {
                font-size: 12px;
            }
            button { font-size: 14px; width: 100%; }
            select, input[type="text"] { width: 100%; }
        }
        @media (min-width: 600px) and (max-width: 1200px) {
            #grid {
                grid-template-columns: repeat(9, 45px);
            }
            .cell {
                width: 45px;
                height: 45px;
                font-size: 15px;
            }
            .vampire { font-size: 15px; }
            .bloodwell::before { font-size: 15px; }
            .arrow { font-size: 15px; }
            .action-icon { font-size: 30px; }
        }
        @media (min-width: 1200px) {
            #grid {
                grid-template-columns: repeat(9, 50px);
            }
            .cell {
                width: 50px;
                height: 50px;
                font-size: 16px;
            }
            .vampire { font-size: 16px; }
            .bloodwell::before { font-size: 16px; }
            .arrow { font-size: 16px; }
            .action-icon { font-size: 40px; }
            h1 { font-size: 24px; }
            #game-info, .class-description, .class-abilities {
                font-size: 14px;
            }
            button { font-size: 16px; }
            input[type="text"] { width: 200px; }
        }
    </style>
</head>
<body>
    <div id="setup-screen">
        <h1>Dreadwood Setup</h1>
        <div id="setup-content"></div>
    </div>

    <div id="game-screen">
        <div id="actions"></div>
        <div id="special-actions"></div>
        <div id="grid-container">
            <div id="grid"></div>
        </div>
        <div id="class-info"></div>
        <div id="game-info">
            <p>Current Player: <span id="current-player">P1</span> | AP Left: <span id="ap-left">4</span> | Turn: <span id="turn">1</span></p>
        </div>
        <div id="controls">
            <button id="undo-button" onclick="undoTurn()" disabled>Undo</button>
            <button onclick="endTurn()">End Turn</button>
        </div>
    </div>
    <div id="elimination-message"></div>
    <div id="victory-message"></div>

    <script>
        const GRID_SIZE = 9;
        const players = ['P1', 'P2', 'P3', 'P4'];
        const classes = ['Sheriff', 'Vigilante', 'Outlaw', 'Bounty Hunter'];
        const apPerTurn = { 1: 4, 2: 5, 3: 6, 4: 8 };
        let gameState = {
            setupStep: 1,
            currentPlayer: 0,
            turn: 1,
            ap: apPerTurn[1],
            playerCount: 0,
            vampires: {},
            bloodwells: {},
            hazards: [],
            selectedVampire: null,
            selectedAction: null,
            playerClasses: {},
            playerNames: {},
            silverBullets: {},
            cursed: {},
            usedAbilities: {},
            layout: null,
            turnHistory: [],
            actionsThisTurn: [],
            availableHazards: {
                tombstone: 4,
                carcass: 4,
                'grave-dust': 4,
                dynamite: 3
            }
        };

        const classInfo = {
            'Sheriff': {
                description: 'A faction of Vampires enforcing order in a chaotic frontier.',
                abilities: [
                    { name: 'Under My Protection', type: 'passive', description: 'Bloodwells adjacent to a Sheriffs‚Äô Vampire (within a 3x3 grid centered on the Vampire) are immune to regular shots.' },
                    { name: 'Swift Justice', type: 'passive', description: 'At the end of the turn, after spending AP, the player may choose one Vampire to move 1 square forward in its facing direction (0 AP).' },
                    { name: 'Order Restored', type: 'active', cost: 3, description: 'Revive a dead Sheriff, placing it adjacent to any of your Vampires or Bloodwells.' }
                ]
            },
            'Vigilante': {
                description: 'A faction of Vampires seeking justice, using teamwork to punish wrongdoers.',
                abilities: [
                    { name: 'Side by Side', type: 'passive', description: 'Split AP between two Vampires each turn.' },
                    { name: 'Blood Brothers', type: 'passive', description: 'If both Vampires are within a 3x3 grid at the start of the turn, gain +1 AP for the turn, provided both use at least 1 AP.' },
                    { name: 'Vengeance is Mine', type: 'active', cost: 0, description: 'Gain 7 AP next turn after a Bloodwell/Vampire is shot, split via Side by Side.' }
                ]
            },
            'Outlaw': {
                description: 'A faction of Vampires thriving on chaos, disrupting and escaping with speed.',
                abilities: [
                    { name: 'Daring Escape', type: 'passive', description: 'After shooting a Bloodwell, pivot to any direction and move up to 2 squares in that direction, once per turn.' },
                    { name: 'Hand Cannon', type: 'active', cost: 5, description: 'Fire a piercing shot in one direction up to 5 spaces, ignores Hazards except Under My Protection.' },
                    { name: 'Rampage', type: 'active', cost: 2, description: 'Shoot left and right of facing direction.' }
                ]
            },
            'Bounty Hunter': {
                description: 'A faction of Vampires hunting for profit, using precision to eliminate targets.',
                abilities: [
                    { name: 'Sharpshooter', type: 'passive', description: 'Shots ignore Tombstones in their line of sight.' },
                    { name: 'Marked Man', type: 'passive', description: 'Shots on enemy Vampires curse them (move 1, shoot own square only, no throw, perform a Bloodbath to heal).' },
                    { name: 'Contract Payoff', type: 'active', cost: 3, description: 'Shoot a Bloodwell; if successful, gain +3 AP next turn (max 8 AP) in 2P, +5 AP (max 10 AP) in 3P/4P.' }
                ]
            }
        };

        const layouts = {
            '2P': [
                {
                    vampires: {
                        'P1': [{ pos: 'A2', facing: 'S' }, { pos: 'C4', facing: 'S' }],
                        'P2': [{ pos: 'A7', facing: 'N' }, { pos: 'C9', facing: 'N' }]
                    },
                    bloodwells: {
                        'P1': ['B1', 'D3', 'F2'],
                        'P2': ['B6', 'D8', 'F7']
                    },
                    hazards: [
                        { type: 'Tombstone', pos: 'E5' },
                        { type: 'Carcass', pos: 'D5' },
                        { type: 'Grave Dust', pos: 'F5' },
                        { type: 'Tombstone', pos: 'G5' },
                        { type: 'Carcass', pos: 'E4' },
                        { type: 'Grave Dust', pos: 'E6' }
                    ]
                },
                // 25 more layouts generated off-screen
            ],
            '3P': [
                {
                    vampires: {
                        'P1': [{ pos: 'A2', facing: 'S' }, { pos: 'C4', facing: 'S' }],
                        'P2': [{ pos: 'F2', facing: 'S' }, { pos: 'H4', facing: 'S' }],
                        'P3': [{ pos: 'D8', facing: 'N' }, { pos: 'F9', facing: 'N' }]
                    },
                    bloodwells: {
                        'P1': ['B1', 'D3', 'A5'],
                        'P2': ['G1', 'I3', 'G5'],
                        'P3': ['C7', 'E6', 'G8']
                    },
                    hazards: [
                        { type: 'Tombstone', pos: 'E5' },
                        { type: 'Carcass', pos: 'D5' },
                        { type: 'Grave Dust', pos: 'F5' },
                        { type: 'Tombstone', pos: 'G5' },
                        { type: 'Carcass', pos: 'H5' },
                        { type: 'Grave Dust', pos: 'B7' }
                    ]
                },
                // 25 more layouts generated off-screen
            ],
            '4P': [
                {
                    vampires: {
                        'P1': [{ pos: 'A2', facing: 'S' }, { pos: 'C4', facing: 'S' }],
                        'P2': [{ pos: 'F2', facing: 'S' }, { pos: 'H4', facing: 'S' }],
                        'P3': [{ pos: 'A7', facing: 'N' }, { pos: 'C9', facing: 'N' }],
                        'P4': [{ pos: 'F7', facing: 'N' }, { pos: 'H9', facing: 'N' }]
                    },
                    bloodwells: {
                        'P1': ['B1', 'D3', 'A3'],
                        'P2': ['G1', 'I3', 'F3'],
                        'P3': ['B6', 'D8', 'A8'],
                        'P4': ['G6', 'I8', 'F8']
                    },
                    hazards: [
                        { type: 'Tombstone', pos: 'E5' },
                        { type: 'Carcass', pos: 'D5' },
                        { type: 'Grave Dust', pos: 'F5' },
                        { type: 'Tombstone', pos: 'G5' },
                        { type: 'Carcass', pos: 'E4' },
                        { type: 'Grave Dust', pos: 'E6' }
                    ]
                },
                // 25 more layouts generated off-screen
            ]
        };

        function renderSetupScreen() {
            const setupContent = document.getElementById('setup-content');
            setupContent.innerHTML = '';
            document.getElementById('game-screen').style.display = 'none';
            document.getElementById('setup-screen').style.display = 'block';

            if (gameState.setupStep === 1) {
                setupContent.innerHTML = `
                    <div class="player-count-buttons">
                        <button onclick="selectPlayerCount(2)">2 Players</button>
                        <button onclick="selectPlayerCount(3)">3 Players</button>
                        <button onclick="selectPlayerCount(4)">4 Players</button>
                    </div>
                `;
            } else if (gameState.setupStep <= gameState.playerCount + 1) {
                const playerNum = gameState.setupStep - 1;
                const player = `P${playerNum}`;
                setupContent.innerHTML = `
                    <h1>Player ${playerNum} Setup</h1>
                    <div class="class-selection">
                        <label>Player ${playerNum} Class:</label>
                        <button class="sheriff" onclick="selectClass('${player}', 'Sheriff')">‚≠ê Sheriff</button>
                        <button class="vigilante" onclick="selectClass('${player}', 'Vigilante')">‚öñÔ∏è Vigilante</button>
                        <button class="outlaw" onclick="selectClass('${player}', 'Outlaw')">üí£ Outlaw</button>
                        <button class="bounty-hunter" onclick="selectClass('${player}', 'Bounty Hunter')">üí∞ Bounty Hunter</button>
                    </div>
                    <div class="class-info" id="class-info-${player}">
                        <p>Select a class to view details.</p>
                    </div>
                    <label for="name-${player}">Player ${playerNum} Name:</label>
                    <input type="text" id="name-${player}" placeholder="${player}" maxlength="20">
                    <button id="back-button-${playerNum}">Back</button>
                    <button id="next-button-${playerNum}">Next</button>
                `;
                const backButton = document.getElementById(`back-button-${playerNum}`);
                const nextButton = document.getElementById(`next-button-${playerNum}`);
                backButton.addEventListener('click', backStep);
                if (gameState.setupStep === gameState.playerCount + 1) {
                    nextButton.textContent = 'Start Game';
                    nextButton.addEventListener('click', startGame);
                } else {
                    nextButton.addEventListener('click', nextStep);
                }
                const nameInput = document.getElementById(`name-${player}`);
                if (gameState.playerNames[player]) {
                    nameInput.value = gameState.playerNames[player];
                }
                if (gameState.playerClasses[player]) {
                    selectClass(player, gameState.playerClasses[player]);
                }
            }
        }

        function selectPlayerCount(count) {
            gameState.playerCount = count;
            gameState.setupStep = 2;
            renderSetupScreen();
        }

        function selectClass(player, className) {
            gameState.playerClasses[player] = className;
            const buttons = document.querySelectorAll(`button[onclick*="selectClass('${player}'"]`);
            buttons.forEach(button => {
                if (button.textContent.includes(className)) {
                    button.classList.add('selected');
                } else {
                    button.classList.remove('selected');
                }
            });

            const classInfoDiv = document.getElementById(`class-info-${player}`);
            const info = classInfo[className];
            const passiveAbilities = info.abilities.filter(ability => ability.type === 'passive');
            const activeAbilities = info.abilities.filter(ability => ability.type === 'active');
            classInfoDiv.innerHTML = `
                <h3 class="class-name">${className}</h3>
                <p class="class-description">${info.description}</p>
                <h4>Passive Skills</h4>
                <ul class="class-abilities">
                    ${passiveAbilities.map(ability => `
                        <li><strong>${ability.name}${ability.cost ? ` (${ability.cost} AP)` : ''}:</strong> ${ability.description}</li>
                    `).join('')}
                </ul>
                <h4>Active Skills</h4>
                <ul class="class-abilities">
                    ${activeAbilities.map(ability => `
                        <li><strong>${ability.name}${ability.cost ? ` (${ability.cost} AP)` : ''}:</strong> ${ability.description}</li>
                    `).join('')}
                </ul>
            `;
        }

        function nextStep() {
            const playerNum = gameState.setupStep - 1;
            const player = `P${playerNum}`;
            if (!gameState.playerClasses[player]) {
                alert(`Please select a class for Player ${playerNum}!`);
                return;
            }
            const nameInput = document.getElementById(`name-${player}`).value.trim();
            gameState.playerNames[player] = nameInput || player;

            gameState.setupStep++;
            renderSetupScreen();
        }

        function backStep() {
            gameState.setupStep--;
            if (gameState.setupStep < 1) gameState.setupStep = 1;
            renderSetupScreen();
        }

        function startGame() {
            console.log("startGame called");
            const playerNum = gameState.setupStep - 1;
            const player = `P${playerNum}`;
            if (!gameState.playerClasses[player]) {
                alert(`Please select a class for Player ${playerNum}!`);
                return;
            }
            const nameInput = document.getElementById(`name-${player}`).value.trim();
            gameState.playerNames[player] = nameInput || player;

            const layoutIndex = Math.floor(Math.random() * 26);
            const layout = layouts[`${gameState.playerCount}P`][layoutIndex];
            gameState.layout = layout;
            gameState.vampires = {};
            gameState.bloodwells = {};
            gameState.hazards = layout.hazards;
            gameState.availableHazards.tombstone = 4 - layout.hazards.filter(h => h.type === 'Tombstone').length;
            gameState.availableHazards.carcass = 4 - layout.hazards.filter(h => h.type === 'Carcass').length;
            gameState.availableHazards['grave-dust'] = 4 - layout.hazards.filter(h => h.type === 'Grave Dust').length;
            gameState.availableHazards.dynamite = 3;

            for (let i = 1; i <= gameState.playerCount; i++) {
                const p = `P${i}`;
                gameState.vampires[p] = layout.vampires[p].map((g, idx) => ({
                    id: `${p}V${idx + 1}`,
                    pos: g.pos,
                    facing: g.facing,
                    alive: true
                }));
                gameState.bloodwells[p] = layout.bloodwells[p];
                gameState.silverBullets[p] = 1;
                gameState.cursed[`${p}V1`] = false;
                gameState.cursed[`${p}V2`] = false;
                gameState.usedAbilities[p] = {};
            }

            document.getElementById('setup-screen').style.display = 'none';
            document.getElementById('game-screen').style.display = 'flex';
            renderGrid();
            updateActionIcons();
            updateClassInfo();
            updateGameInfo();
        }

        function renderGrid() {
            console.log("renderGrid called");
            const grid = document.getElementById('grid');
            grid.innerHTML = '';
            grid.style.display = 'grid';
            for (let row = 1; row <= GRID_SIZE; row++) {
                for (let col = 1; col <= GRID_SIZE; col++) {
                    const pos = String.fromCharCode(64 + col) + row;
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.id = pos;
                    cell.onclick = () => selectCell(pos);

                    let content = '';
                    let hasVampire = false;
                    let hasHazard = false;
                    let hazardType = '';

                    for (let player in gameState.vampires) {
                        const vampire = gameState.vampires[player].find(g => g.pos === pos && g.alive);
                        if (vampire) {
                            content = '‚ôüÔ∏è';
                            cell.classList.add('vampire');
                            cell.classList.add(gameState.playerClasses[player].toLowerCase());
                            if (gameState.cursed[vampire.id]) cell.classList.add('cursed');
                            hasVampire = true;
                            break;
                        }
                    }

                    if (!hasVampire) {
                        for (let player in gameState.bloodwells) {
                            if (gameState.bloodwells[player].includes(pos)) {
                                content = '';
                                cell.classList.add('bloodwell');
                                cell.classList.add(gameState.playerClasses[player].toLowerCase());
                                break;
                            }
                        }
                    }

                    const hazard = gameState.hazards.find(o => o.pos === pos);
                    if (hazard) {
                        hasHazard = true;
                        hazardType = hazard.type.toLowerCase().replace(' ', '-');
                        if (!hasVampire) {
                            content = '';
                            cell.classList.add(hazardType);
                        }
                    }

                    cell.innerHTML += content;
                    grid.appendChild(cell);
                }
            }

            if (gameState.selectedVampire) {
                const pos = gameState.selectedVampire.pos;
                const cell = document.getElementById(pos);
                cell.classList.add('selected');

                const [col, row] = [pos.charCodeAt(0) - 64, parseInt(pos[1])];
                const directions = [
                    { dir: 'N', pos: `${String.fromCharCode(64 + col)}${row - 1}`, emoji: '‚¨ÜÔ∏è' },
                    { dir: 'S', pos: `${String.fromCharCode(64 + col)}${row + 1}`, emoji: '‚¨áÔ∏è' },
                    { dir: 'E', pos: `${String.fromCharCode(64 + col + 1)}${row}`, emoji: '‚û°Ô∏è' },
                    { dir: 'W', pos: `${String.fromCharCode(64 + col - 1)}${row}`, emoji: '‚¨ÖÔ∏è' }
                ];

                directions.forEach(({ dir, pos, emoji }) => {
                    if (row > 1 && dir === 'N' || row < GRID_SIZE && dir === 'S' || col > 1 && dir === 'W' || col < GRID_SIZE && dir === 'E') {
                        const arrowCell = document.getElementById(pos);
                        if (arrowCell) {
                            const arrow = document.createElement('div');
                            arrow.className = 'arrow';
                            arrow.innerHTML = emoji;
                            arrow.onclick = () => handleArrowClick(dir);
                            arrowCell.appendChild(arrow);
                        }
                    }
                });
            }
        }

        function updateActionIcons() {
            console.log("updateActionIcons called");
            const actionsDiv = document.getElementById('actions');
            const specialActionsDiv = document.getElementById('special-actions');
            actionsDiv.style.display = 'flex';
            specialActionsDiv.style.display = 'flex';
            actionsDiv.innerHTML = `
                <div class="action-icon" onclick="selectAction('shoot')">üî´</div>
                <span class="action-separator">|</span>
                <div class="action-icon" onclick="selectThrow('Tombstone')">ü™¶</div>
                <span class="action-separator">|</span>
                <div class="action-icon" onclick="selectThrow('Carcass')">üíÄ</div>
                <span class="action-separator">|</span>
                <div class="action-icon" onclick="selectThrow('Grave Dust')">üí©</div>
                <span class="action-separator">|</span>
                <div class="action-icon" onclick="selectThrow('Dynamite')">üí•</div>
            `;

            let specialActions = [];
            if (gameState.selectedVampire) {
                const pos = gameState.selectedVampire.pos;
                const hazard = gameState.hazards.find(o => o.pos === pos);
                if (hazard && hazard.type === 'Dynamite') {
                    specialActions.push(`<div class="action-icon" onclick="selectAction('bite')">üçΩÔ∏èüí•ü§¢</div>`);
                }
                if (hazard && hazard.type === 'Grave Dust') {
                    specialActions.push(`<div class="action-icon" onclick="selectAction('dispel')">ü™Ñ</div>`);
                }
            }

            const player = players[gameState.currentPlayer];
            if (!gameState.usedAbilities[player]?.['Blood Ritual']) {
                specialActions.push(`<div class="action-icon" onclick="selectAction('bloodRitual')">ü©∏ü™Ñ</div>`);
            }

            const className = gameState.playerClasses[player];
            if (className === 'Sheriff' && !gameState.usedAbilities[player]?.['Order Restored']) {
                specialActions.push(`<div class="action-icon" onclick="selectAbility('Order Restored')">‚≠ê‚ûï</div>`);
            } else if (className === 'Vigilante' && !gameState.usedAbilities[player]?.['Vengeance is Mine']) {
                specialActions.push(`<div class="action-icon" onclick="selectAbility('Vengeance is Mine')">‚öñÔ∏èüòè</div>`);
            } else if (className === 'Outlaw') {
                if (!gameState.usedAbilities[player]?.['Hand Cannon']) {
                    specialActions.push(`<div class="action-icon" onclick="selectAbility('Hand Cannon')">üöÄ</div>`);
                }
                if (!gameState.usedAbilities[player]?.['Rampage']) {
                    specialActions.push(`<div class="action-icon" onclick="selectAbility('Rampage')"><span style="color: #ff4500;">‚è™</span>üò°<span style="color: #ff4500;">‚è©</span></div>`);
                }
            } else if (className === 'Bounty Hunter' && !gameState.usedAbilities[player]?.['Contract Payoff']) {
                specialActions.push(`<div class="action-icon" onclick="selectAbility('Contract Payoff')">üìúüí∞</div>`);
            }

            if (gameState.silverBullets[player] > 0) {
                specialActions.push(`<div class="action-icon" onclick="selectAction('silverBullet')">üî´üíé</div>`);
            }

            specialActionsDiv.innerHTML = specialActions.join('<span class="action-separator">|</span>');
        }

        function selectCell(pos) {
            const player = players[gameState.currentPlayer];
            const vampire = gameState.vampires[player].find(g => g.pos === pos && g.alive);
            if (vampire) {
                gameState.selectedVampire = vampire;
                gameState.selectedAction = null;
                renderGrid();
                updateClassInfo();
                updateActionIcons();
            } else if (gameState.selectedVampire && gameState.selectedAction) {
                executeAction(pos);
            }
        }

        function selectAction(action) {
            gameState.selectedAction = action;
            renderGrid();
            updateActionIcons();
        }

        function selectThrow(hazard) {
            if (gameState.availableHazards[hazard.toLowerCase().replace(' ', '-')] <= 0) {
                alert(`No ${hazard} Hazards available to throw!`);
                return;
            }
            gameState.selectedAction = 'throw';
            gameState.selectedHazard = hazard;
            renderGrid();
        }

        function selectAbility(abilityName) {
            const player = players[gameState.currentPlayer];
            if (confirm(`${abilityName} can only be used once per game. Are you sure?`)) {
                gameState.selectedAction = 'ability';
                gameState.selectedAbility = abilityName;
                renderGrid();
            }
        }

        function handleArrowClick(direction) {
            if (!gameState.selectedVampire) return;
            const vampire = gameState.selectedVampire;
            if (gameState.cursed[vampire.id]) {
                alert("This Vampire is cursed and cannot move more than 1 square!");
                return;
            }

            if (vampire.facing === direction) {
                gameState.selectedAction = 'move';
            } else {
                gameState.selectedAction = 'pivot';
                gameState.selectedDirection = direction;
            }
            const [col, row] = [vampire.pos.charCodeAt(0) - 64, parseInt(vampire.pos[1])];
            let targetPos;
            if (direction === 'N') targetPos = `${String.fromCharCode(64 + col)}${row - 1}`;
            if (direction === 'S') targetPos = `${String.fromCharCode(64 + col)}${row + 1}`;
            if (direction === 'E') targetPos = `${String.fromCharCode(64 + col + 1)}${row}`;
            if (direction === 'W') targetPos = `${String.fromCharCode(64 + col - 1)}${row}`;
            executeAction(targetPos);
        }

        function executeAction(targetPos) {
            const player = players[gameState.currentPlayer];
            const vampire = gameState.selectedVampire;
            const action = gameState.selectedAction;
            let apCost = 0;

            const currentState = JSON.parse(JSON.stringify({
                vampires: gameState.vampires,
                bloodwells: gameState.bloodwells,
                hazards: gameState.hazards,
                cursed: gameState.cursed,
                usedAbilities: gameState.usedAbilities,
                ap: gameState.ap,
                silverBullets: gameState.silverBullets,
                availableHazards: gameState.availableHazards
            }));
            gameState.actionsThisTurn.push(currentState);

            if (action === 'move') {
                apCost = 1;
                if (gameState.ap >= apCost) {
                    const newPos = canMove(vampire, targetPos);
                    if (newPos) {
                        vampire.pos = targetPos;
                        gameState.ap -= apCost;
                        alert(`${gameState.playerNames[player]}'s ${vampire.id} moved to ${targetPos}`);
                        if (gameState.cursed[vampire.id]) {
                            const hasBloodwell = gameState.bloodwells[player].includes(targetPos);
                            const hasHazard = gameState.hazards.some(h => h.pos === targetPos);
                            if (hasBloodwell && !hasHazard) {
                                gameState.cursed[vampire.id] = false;
                                alert(`${gameState.playerNames[player]}'s ${vampire.id} performed a Bloodbath at ${targetPos} and is no longer cursed!`);
                            }
                        }
                    }
                }
            } else if (action === 'pivot') {
                apCost = 1;
                if (gameState.ap >= apCost) {
                    vampire.facing = gameState.selectedDirection;
                    gameState.ap -= apCost;
                    alert(`${gameState.playerNames[player]}'s ${vampire.id} pivoted to face ${vampire.facing}`);
                }
            } else if (action === 'shoot') {
                apCost = 3;
                if (gameState.ap >= apCost) {
                    const target = canShoot(vampire, targetPos);
                    if (target) {
                        handleShot(vampire, targetPos);
                        gameState.ap -= apCost;
                    }
                }
            } else if (action === 'throw') {
                const hazardType = gameState.selectedHazard;
                apCost = hazardType === 'Dynamite' ? 2 : 1;
                if (gameState.ap >= apCost) {
                    const canThrow = canThrowHazard(vampire, targetPos, hazardType);
                    if (canThrow) {
                        gameState.hazards.push({ type: hazardType, pos: targetPos });
                        gameState.availableHazards[hazardType.toLowerCase().replace(' ', '-')]--;
                        gameState.ap -= apCost;
                        alert(`${gameState.playerNames[player]}'s ${vampire.id} threw ${hazardType} to ${targetPos}`);
                    }
                }
            } else if (action === 'dispel') {
                apCost = 3;
                if (gameState.ap >= apCost) {
                    const pos = vampire.pos;
                    const hazard = gameState.hazards.find(o => o.pos === pos && o.type === 'Grave Dust');
                    if (hazard) {
                        gameState.hazards = gameState.hazards.filter(o => o !== hazard);
                        gameState.availableHazards['grave-dust']++;
                        gameState.ap -= apCost;
                        alert(`${gameState.playerNames[player]}'s ${vampire.id} dispelled the Grave Dust at ${pos}`);
                    }
                }
            } else if (action === 'bite') {
                apCost = 1;
                if (gameState.ap >= apCost) {
                    const pos = vampire.pos;
                    const hazard = gameState.hazards.find(o => o.pos === pos && o.type === 'Dynamite');
                    if (hazard) {
                        gameState.hazards = gameState.hazards.filter(o => o !== hazard);
                        gameState.availableHazards.dynamite++;
                        gameState.cursed[vampire.id] = true;
                        gameState.ap -= apCost;
                        alert(`${gameState.playerNames[player]}'s ${vampire.id} bit the fuse at ${pos} and is now cursed!`);
                    }
                }
            } else if (action === 'bloodRitual') {
                apCost = 3;
                if (gameState.ap >= apCost) {
                    const target = canShoot(vampire, targetPos);
                    if (target && gameState.bloodwells[player].includes(targetPos)) {
                        gameState.bloodwells[player] = gameState.bloodwells[player].filter(pos => pos !== targetPos);
                        const deadVampire = gameState.vampires[player].find(g => !g.alive);
                        if (deadVampire) {
                            deadVampire.alive = true;
                            deadVampire.pos = targetPos;
                            gameState.ap -= apCost;
                            gameState.usedAbilities[player]['Blood Ritual'] = true;
                            alert(`${gameState.playerNames[player]} used Blood Ritual: Sacrificed a Bloodwell at ${targetPos} to revive ${deadVampire.id}`);
                        } else {
                            alert("No dead Vampires to revive! The Bloodwell is still destroyed.");
                            gameState.actionsThisTurn.pop();
                            return;
                        }
                    } else {
                        alert("Blood Ritual requires shooting your own Bloodwell!");
                        gameState.actionsThisTurn.pop();
                        return;
                    }
                }
            } else if (action === 'silverBullet') {
                apCost = 3;
                if (gameState.ap >= apCost && gameState.silverBullets[player] > 0) {
                    const target = canShoot(vampire, targetPos);
                    if (target) {
                        let hitVampire = false;
                        for (let p in gameState.vampires) {
                            const targetVampire = gameState.vampires[p].find(g => g.pos === targetPos && g.alive);
                            if (targetVampire && p !== player) {
                                targetVampire.alive = false;
                                gameState.silverBullets[player]--;
                                gameState.ap -= apCost;
                                alert(`${gameState.playerNames[player]}'s ${vampire.id} used a Silver Bullet to eliminate ${gameState.playerNames[p]}'s ${targetVampire.id} at ${targetPos}`);
                                hitVampire = true;
                                break;
                            }
                        }
                        if (!hitVampire) {
                            handleShot(vampire, targetPos, true);
                            gameState.silverBullets[player]--;
                            gameState.ap -= apCost;
                            alert(`${gameState.playerNames[player]}'s ${vampire.id} used a Silver Bullet but missed a Vampire! The bullet acted as a normal shot.`);
                        }
                    }
                }
            } else if (action === 'ability') {
                const ability = gameState.selectedAbility;
                if (ability === 'Order Restored') {
                    apCost = 3;
                    if (gameState.ap >= apCost) {
                        const deadVampire = gameState.vampires[player].find(g => !g.alive);
                        if (deadVampire) {
                            deadVampire.alive = true;
                            deadVampire.pos = targetPos;
                            gameState.ap -= apCost;
                            gameState.usedAbilities[player]['Order Restored'] = true;
                            alert(`${gameState.playerNames[player]} used Order Restored: Revived ${deadVampire.id} at ${targetPos}`);
                        } else {
                            alert("No dead Vampires to revive!");
                            gameState.actionsThisTurn.pop();
                            return;
                        }
                    }
                } else if (ability === 'Vengeance is Mine') {
                    alert("Vengeance is Mine triggers on opponent shot!");
                    gameState.actionsThisTurn.pop();
                    return;
                } else if (ability === 'Hand Cannon') {
                    apCost = 5;
                    if (gameState.ap >= apCost) {
                        const direction = prompt("Choose direction for Hand Cannon (N, S, E, W):", vampire.facing);
                        if (['N', 'S', 'E', 'W'].includes(direction)) {
                            handleHandCannon(vampire, direction);
                            gameState.ap -= apCost;
                            gameState.usedAbilities[player]['Hand Cannon'] = true;
                        } else {
                            alert("Invalid direction!");
                            gameState.actionsThisTurn.pop();
                            return;
                        }
                    }
                } else if (ability === 'Rampage') {
                    apCost = 2;
                    if (gameState.ap >= apCost) {
                        handleRampage(vampire);
                        gameState.ap -= apCost;
                        gameState.usedAbilities[player]['Rampage'] = true;
                    }
                } else if (ability === 'Contract Payoff') {
                    apCost = 3;
                    if (gameState.ap >= apCost) {
                        const target = canShoot(vampire, targetPos);
                        if (target && target.includes('B')) {
                            gameState.bloodwells[player].includes(targetPos) ? gameState.bloodwells[player] = gameState.bloodwells[player].filter(pos => pos !== targetPos) : null;
                            gameState.ap -= apCost;
                            gameState.usedAbilities[player]['Contract Payoff'] = true;
                            alert(`${gameState.playerNames[player]} used Contract Payoff: Shot ${target}, +${gameState.playerCount === 2 ? 3 : 5} AP next turn`);
                            // AP boost logic handled in endTurn
                        } else {
                            alert("Contract Payoff requires shooting a Bloodwell!");
                            gameState.actionsThisTurn.pop();
                            return;
                        }
                    }
                }
            }

            gameState.selectedVampire = null;
            gameState.selectedAction = null;
            renderGrid();
            updateGameInfo();
            updateClassInfo();
            updateActionIcons();
            checkGameState();
            document.getElementById('undo-button').disabled = gameState.actionsThisTurn.length === 0;
        }

        function canMove(vampire, targetPos) {
            const [targetCol, targetRow] = [targetPos.charCodeAt(0) - 64, parseInt(targetPos[1])];
            const [currentCol, currentRow] = [vampire.pos.charCodeAt(0) - 64, parseInt(vampire.pos[1])];
            const direction = vampire.facing;
            if (direction === 'N' && targetRow < currentRow && targetCol === currentCol) {
                const targetHazard = gameState.hazards.find(h => h.pos === targetPos);
                if (targetHazard && targetHazard.type === 'Carcass') {
                    alert("Cannot move through a Carcass!");
                    return false;
                }
                return true;
            }
            if (direction === 'S' && targetRow > currentRow && targetCol === currentCol) {
                const targetHazard = gameState.hazards.find(h => h.pos === targetPos);
                if (targetHazard && targetHazard.type === 'Carcass') {
                    alert("Cannot move through a Carcass!");
                    return false;
                }
                return true;
            }
            if (direction === 'E' && targetCol > currentCol && targetRow === currentRow) {
                const targetHazard = gameState.hazards.find(h => h.pos === targetPos);
                if (targetHazard && targetHazard.type === 'Carcass') {
                    alert("Cannot move through a Carcass!");
                    return false;
                }
                return true;
            }
            if (direction === 'W' && targetCol < currentCol && targetRow === currentRow) {
                const targetHazard = gameState.hazards.find(h => h.pos === targetPos);
                if (targetHazard && targetHazard.type === 'Carcass') {
                    alert("Cannot move through a Carcass!");
                    return false;
                }
                return true;
            }
            alert("Invalid move direction!");
            return false;
        }

        function canShoot(vampire, targetPos) {
            const [targetCol, targetRow] = [targetPos.charCodeAt(0) - 64, parseInt(targetPos[1])];
            const [currentCol, currentRow] = [vampire.pos.charCodeAt(0) - 64, parseInt(vampire.pos[1])];
            const direction = vampire.facing;
            let path = [];
            if (direction === 'N' && targetCol === currentCol && targetRow < currentRow) {
                for (let r = currentRow - 1; r >= targetRow; r--) path.push(`${String.fromCharCode(64 + currentCol)}${r}`);
            } else if (direction === 'S' && targetCol === currentCol && targetRow > currentRow) {
                for (let r = currentRow + 1; r <= targetRow; r++) path.push(`${String.fromCharCode(64 + currentCol)}${r}`);
            } else if (direction === 'E' && targetRow === currentRow && targetCol > currentCol) {
                for (let c = currentCol + 1; c <= targetCol; c++) path.push(`${String.fromCharCode(64 + c)}${currentRow}`);
            } else if (direction === 'W' && targetRow === currentRow && targetCol < currentCol) {
                for (let c = currentCol - 1; c >= targetCol; c++) path.push(`${String.fromCharCode(64 + c)}${currentRow}`);
            } else {
                alert("Invalid shot direction!");
                return null;
            }

            for (let pos of path.slice(0, -1)) {
                const hazard = gameState.hazards.find(o => o.pos === pos);
                if (hazard) {
                    if (gameState.playerClasses[players[gameState.currentPlayer]] === 'Bounty Hunter' && hazard.type === 'Tombstone') {
                        continue;
                    }
                    if (hazard.type === 'Tombstone' || hazard.type === 'Dynamite') {
                        alert("Shot blocked by Hazard!");
                        return null;
                    }
                }
            }

            for (let player in gameState.vampires) {
                const targetVampire = gameState.vampires[player].find(g => g.pos === path[path.length - 1] && g.alive);
                if (targetVampire && gameState.playerClasses[player] === 'Sheriff') {
                    for (let bloodwell of gameState.bloodwells[player]) {
                        const [bCol, bRow] = [bloodwell.charCodeAt(0) - 64, parseInt(bloodwell[1])];
                        if (Math.abs(bCol - targetCol) <= 1 && Math.abs(bRow - targetRow) <= 1) {
                            alert("Shot blocked by Under My Protection!");
                            return null;
                        }
                    }
                }
            }

            return path[path.length - 1];
        }

        function handleShot(vampire, targetPos, isSilverBullet = false) {
            const player = players[gameState.currentPlayer];
            for (let p in gameState.bloodwells) {
                if (gameState.bloodwells[p].includes(targetPos)) {
                    gameState.bloodwells[p] = gameState.bloodwells[p].filter(pos => pos !== targetPos);
                    alert(`${gameState.playerNames[player]}'s ${vampire.id} shot ${gameState.playerNames[p]}'s Bloodwell at ${targetPos}`);
                    if (gameState.playerClasses[p] === 'Vigilante') {
                        alert(`${gameState.playerNames[p]} triggers Vengeance is Mine: +7 AP next turn`);
                        gameState.usedAbilities[p]['Vengeance is Mine'] = true;
                    }
                    if (gameState.playerClasses[player] === 'Outlaw') {
                        gameState.selectedAction = 'daringEscape';
                        renderGrid();
                    }
                    return;
                }
            }

            for (let p in gameState.vampires) {
                const targetVampire = gameState.vampires[p].find(g => g.pos === targetPos && g.alive);
                if (targetVampire) {
                    if (gameState.playerClasses[player] === 'Bounty Hunter') {
                        gameState.cursed[targetVampire.id] = true;
                        alert(`${gameState.playerNames[player]}'s ${vampire.id} cursed ${gameState.playerNames[p]}'s ${targetVampire.id} with Marked Man`);
                    } else if (isSilverBullet) {
                        targetVampire.alive = false;
                        alert(`${gameState.playerNames[player]}'s ${vampire.id} used a Silver Bullet to eliminate ${gameState.playerNames[p]}'s ${targetVampire.id} at ${targetPos}`);
                    } else {
                        alert("Shot ignored‚Äîuse a Silver Bullet to eliminate!");
                    }
                    return;
                }
            }

            const hazard = gameState.hazards.find(o => o.pos === targetPos);
            if (hazard) {
                if (hazard.type === 'Dynamite') {
                    handleDynamiteExplosion(targetPos);
                } else {
                    gameState.hazards = gameState.hazards.filter(o => o.pos !== targetPos);
                    gameState.availableHazards[hazard.type.toLowerCase().replace(' ', '-')]++;
                    alert(`${gameState.playerNames[player]}'s ${vampire.id} destroyed ${hazard.type} at ${targetPos}`);
                }
            }
        }

        function handleDynamiteExplosion(pos) {
            const [col, row] = [pos.charCodeAt(0) - 64, parseInt(pos[1])];
            const radius = 3;
            const affected = [];
            for (let r = Math.max(1, row - 1); r <= Math.min(9, row + 1); r++) {
                for (let c = Math.max(1, col - 1); c <= Math.min(9, col + 1); c++) {
                    affected.push(`${String.fromCharCode(64 + c)}${r}`);
                }
            }

            gameState.hazards = gameState.hazards.filter(o => o.pos !== pos);
            gameState.availableHazards.dynamite++;
            alert(`Dynamite exploded at ${pos}, affecting ${affected.length} squares`);

            for (let p in gameState.bloodwells) {
                gameState.bloodwells[p] = gameState.bloodwells[p].filter(b => !affected.includes(b));
                if (gameState.bloodwells[p].length === 0) {
                    showEliminationMessage(p);
                }
            }

            gameState.hazards = gameState.hazards.filter(h => !affected.includes(h.pos));
            affected.forEach(pos => {
                const hazard = gameState.hazards.find(h => h.pos === pos);
                if (hazard) {
                    gameState.availableHazards[hazard.type.toLowerCase().replace(' ', '-')]++;
                }
            });
        }

        function canThrowHazard(vampire, targetPos, type) {
            const [targetCol, targetRow] = [targetPos.charCodeAt(0) - 64, parseInt(targetPos[1])];
            const [currentCol, currentRow] = [vampire.pos.charCodeAt(0) - 64, parseInt(vampire.pos[1])];
            const direction = vampire.facing;
            let path = [];
            if (direction === 'N' && targetCol === currentCol && targetRow < currentRow) {
                for (let r = currentRow - 1; r >= targetRow; r--) path.push(`${String.fromCharCode(64 + currentCol)}${r}`);
            } else if (direction === 'S' && targetCol === currentCol && targetRow > currentRow) {
                for (let r = currentRow + 1; r <= targetRow; r++) path.push(`${String.fromCharCode(64 + currentCol)}${r}`);
            } else if (direction === 'E' && targetRow === currentRow && targetCol > currentCol) {
                for (let c = currentCol + 1; c <= targetCol; c++) path.push(`${String.fromCharCode(64 + c)}${currentRow}`);
            } else if (direction === 'W' && targetRow === currentRow && targetCol < currentCol) {
                for (let c = currentCol - 1; c >= targetCol; c++) path.push(`${String.fromCharCode(64 + c)}${currentRow}`);
            } else {
                alert("Invalid throw direction!");
                return false;
            }

            if (path.length > 3) {
                alert("Throw distance exceeds 3 squares!");
                return false;
            }

            for (let pos of path.slice(0, -1)) {
                if (gameState.hazards.some(o => o.pos === pos && o.type === 'Carcass') || Object.values(gameState.vampires).flat().some(g => g.pos === pos && g.alive)) {
                    alert("Throw path blocked!");
                    return false;
                }
            }

            const targetOccupied = Object.values(gameState.vampires).flat().some(g => g.pos === targetPos && g.alive) || gameState.hazards.some(o => o.pos === targetPos);
            if (type === 'Grave Dust' && targetOccupied) {
                const targetVampire = Object.values(gameState.vampires).flat().find(g => g.pos === targetPos && g.alive);
                if (targetVampire) {
                    gameState.cursed[targetVampire.id] = true;
                    alert(`${vampire.id} cursed ${targetVampire.id} with Grave Dust`);
                    return false;
                }
            } else if (targetOccupied) {
                alert("Target square occupied!");
                return false;
            }

            return true;
        }

        function handleHandCannon(vampire, direction) {
            const [currentCol, currentRow] = [vampire.pos.charCodeAt(0) - 64, parseInt(vampire.pos[1])];
            let path = [];
            if (direction === 'N') {
                for (let r = currentRow - 1; r >= Math.max(1, currentRow - 5); r--) path.push(`${String.fromCharCode(64 + currentCol)}${r}`);
            } else if (direction === 'S') {
                for (let r = currentRow + 1; r <= Math.min(9, currentRow + 5); r++) path.push(`${String.fromCharCode(64 + currentCol)}${r}`);
            } else if (direction === 'E') {
                for (let c = currentCol + 1; c <= Math.min(9, currentCol + 5); c++) path.push(`${String.fromCharCode(64 + c)}${currentRow}`);
            } else if (direction === 'W') {
                for (let c = currentCol - 1; c >= Math.max(1, currentCol - 5); c++) path.push(`${String.fromCharCode(64 + c)}${currentRow}`);
            }

            for (let pos of path) {
                for (let p in gameState.bloodwells) {
                    if (gameState.bloodwells[p].includes(pos)) {
                        gameState.bloodwells[p] = gameState.bloodwells[p].filter(b => b !== pos);
                        alert(`${gameState.playerNames[players[gameState.currentPlayer]]}'s ${vampire.id} Hand Cannon hit ${gameState.playerNames[p]}'s Bloodwell at ${pos}`);
                    }
                }
                const hazard = gameState.hazards.find(o => o.pos === pos);
                if (hazard) {
                    if (hazard.type === 'Dynamite') {
                        handleDynamiteExplosion(pos);
                    } else {
                        gameState.hazards = gameState.hazards.filter(o => o.pos !== pos);
                        gameState.availableHazards[hazard.type.toLowerCase().replace(' ', '-')]++;
                        alert(`${gameState.playerNames[players[gameState.currentPlayer]]}'s ${vampire.id} Hand Cannon destroyed ${hazard.type} at ${pos}`);
                    }
                }
            }
        }

        function handleRampage(vampire) {
            const [col, row] = [vampire.pos.charCodeAt(0) - 64, parseInt(vampire.pos[1])];
            const direction = vampire.facing;
            let leftPos, rightPos;
            if (direction === 'N' || direction === 'S') {
                leftPos = col > 1 ? `${String.fromCharCode(64 + col - 1)}${row}` : null;
                rightPos = col < 9 ? `${String.fromCharCode(64 + col + 1)}${row}` : null;
            } else {
                leftPos = row > 1 ? `${String.fromCharCode(64 + col)}${row - 1}` : null;
                rightPos = row < 9 ? `${String.fromCharCode(64 + col)}${row + 1}` : null;
            }

            [leftPos, rightPos].forEach(pos => {
                if (pos) {
                    for (let p in gameState.bloodwells) {
                        if (gameState.bloodwells[p].includes(pos)) {
                            gameState.bloodwells[p] = gameState.bloodwells[p].filter(b => b !== pos);
                            alert(`${gameState.playerNames[players[gameState.currentPlayer]]}'s ${vampire.id} Rampage hit ${gameState.playerNames[p]}'s Bloodwell at ${pos}`);
                        }
                    }
                    const hazard = gameState.hazards.find(o => o.pos === pos);
                    if (hazard) {
                        if (hazard.type === 'Dynamite') {
                            handleDynamiteExplosion(pos);
                        } else {
                            gameState.hazards = gameState.hazards.filter(o => o.pos !== pos);
                            gameState.availableHazards[hazard.type.toLowerCase().replace(' ', '-')]++;
                            alert(`${gameState.playerNames[players[gameState.currentPlayer]]}'s ${vampire.id} Rampage destroyed ${hazard.type} at ${pos}`);
                        }
                    }
                }
            });
        }

        function endTurn() {
            const player = players[gameState.currentPlayer];
            if (gameState.playerClasses[player] === 'Sheriff') {
                const vampire = gameState.vampires[player].find(g => g.alive);
                if (vampire) {
                    const [col, row] = [vampire.pos.charCodeAt(0) - 64, parseInt(vampire.pos[1])];
                    let targetPos;
                    if (vampire.facing === 'N' && row > 1) targetPos = `${String.fromCharCode(64 + col)}${row - 1}`;
                    if (vampire.facing === 'S' && row < GRID_SIZE) targetPos = `${String.fromCharCode(64 + col)}${row + 1}`;
                    if (vampire.facing === 'E' && col < GRID_SIZE) targetPos = `${String.fromCharCode(64 + col + 1)}${row}`;
                    if (vampire.facing === 'W' && col > 1) targetPos = `${String.fromCharCode(64 + col - 1)}${row}`;
                    if (targetPos && canMove(vampire, targetPos)) {
                        vampire.pos = targetPos;
                        alert(`${gameState.playerNames[player]}'s ${vampire.id} moved to ${targetPos} via Swift Justice`);
                    }
                }
            }

            gameState.currentPlayer = (gameState.currentPlayer + 1) % gameState.playerCount;
            gameState.turn++;
            gameState.ap = apPerTurn[gameState.currentPlayer + 1];
            if (gameState.playerClasses[players[gameState.currentPlayer]] === 'Vigilante') {
                const v1 = gameState.vampires[players[gameState.currentPlayer]][0];
                const v2 = gameState.vampires[players[gameState.currentPlayer]][1];
                const [col1, row1] = [v1.pos.charCodeAt(0) - 64, parseInt(v1.pos[1])];
                const [col2, row2] = [v2.pos.charCodeAt(0) - 64, parseInt(v2.pos[1])];
                if (Math.abs(col1 - col2) <= 2 && Math.abs(row1 - row2) <= 2) {
                    gameState.ap += 1;
                    gameState.bloodBrothersActive = true;
                } else {
                    gameState.bloodBrothersActive = false;
                }
            }
            if (gameState.usedAbilities[players[gameState.currentPlayer]]?.['Contract Payoff']) {
                gameState.ap += gameState.playerCount === 2 ? 3 : 5;
                gameState.ap = Math.min(gameState.ap, gameState.playerCount === 2 ? 8 : 10);
                delete gameState.usedAbilities[players[gameState.currentPlayer]]['Contract Payoff'];
            }
            gameState.selectedVampire = null;
            gameState.selectedAction = null;
            gameState.actionsThisTurn = [];
            gameState.turnHistory = [];
            document.getElementById('undo-button').disabled = true;
            alert(`Turn ended. Now ${gameState.playerNames[players[gameState.currentPlayer]]}'s turn.`);
            renderGrid();
            updateGameInfo();
            updateClassInfo();
            updateActionIcons();
        }

        function undoTurn() {
            if (gameState.actionsThisTurn.length === 0) return;
            const lastState = gameState.actionsThisTurn.pop();
            gameState.vampires = JSON.parse(JSON.stringify(lastState.vampires));
            gameState.bloodwells = JSON.parse(JSON.stringify(lastState.bloodwells));
            gameState.hazards = JSON.parse(JSON.stringify(lastState.hazards));
            gameState.cursed = JSON.parse(JSON.stringify(lastState.cursed));
            gameState.usedAbilities = JSON.parse(JSON.stringify(lastState.usedAbilities));
            gameState.ap = lastState.ap;
            gameState.silverBullets = JSON.parse(JSON.stringify(lastState.silverBullets));
            gameState.availableHazards = JSON.parse(JSON.stringify(lastState.availableHazards));
            gameState.selectedVampire = null;
            gameState.selectedAction = null;
            renderGrid();
            updateGameInfo();
            updateClassInfo();
            updateActionIcons();
            document.getElementById('undo-button').disabled = gameState.actionsThisTurn.length === 0;
        }

        function updateGameInfo() {
            document.getElementById('current-player').textContent = gameState.playerNames[players[gameState.currentPlayer]];
            document.getElementById('ap-left').textContent = gameState.ap;
            document.getElementById('turn').textContent = gameState.turn;
        }

        function updateClassInfo() {
            const player = players[gameState.currentPlayer];
            const className = gameState.playerClasses[player];
            const info = classInfo[className];
            const classInfoDiv = document.getElementById('class-info');
            classInfoDiv.innerHTML = `
                <h3 class="class-name">${className}</h3>
                <p class="class-description">${info.description}</p>
                <ul class="class-abilities">
                    ${info.abilities.map(ability => `
                        <li class="${ability.type === 'active' && gameState.usedAbilities[player]?.[ability.name] ? 'used' : ''} ${ability.type === 'active' && !gameState.usedAbilities[player]?.[ability.name] ? 'active-ability' : ''}" 
                            onclick="${ability.type === 'active' && !gameState.usedAbilities[player]?.[ability.name] ? `selectAbility('${ability.name}')` : ''}">
                            <strong>${ability.name}${ability.cost ? ` (${ability.cost} AP)` : ''}:</strong> ${ability.description}
                        </li>
                    `).join('')}
                </ul>
            `;
        }

        function showEliminationMessage(player) {
            const messageDiv = document.getElementById('elimination-message');
            messageDiv.textContent = `Player Eliminated! ${gameState.playerNames[player]} has been eliminated from the game.`;
            messageDiv.style.display = 'block';
            setTimeout(() => {
                messageDiv.style.display = 'none';
                checkGameState();
            }, 3000);
        }

        function showVictoryMessage(winner) {
            const messageDiv = document.getElementById('victory-message');
            messageDiv.innerHTML = `
                Victory! ${gameState.playerNames[winner]} Wins! All enemy Bloodwells or Vampires destroyed.
                <button onclick="restartGame()">Restart Game</button>
            `;
            messageDiv.style.display = 'block';
        }

        function checkGameState() {
            const remainingPlayers = players.slice(0, gameState.playerCount).filter(p => 
                gameState.bloodwells[p].length > 0 && gameState.vampires[p].some(v => v.alive)
            );
            if (remainingPlayers.length === 1) {
                showVictoryMessage(remainingPlayers[0]);
            }
        }

        function restartGame() {
            document.getElementById('victory-message').style.display = 'none';
            document.getElementById('game-screen').style.display = 'none';
            document.getElementById('setup-screen').style.display = 'block';
            gameState = {
                setupStep: 1,
                currentPlayer: 0,
                turn: 1,
                ap: apPerTurn[1],
                playerCount: 0,
                vampires: {},
                bloodwells: {},
                hazards: [],
                selectedVampire: null,
                selectedAction: null,
                playerClasses: {},
                playerNames: {},
                silverBullets: {},
                cursed: {},
                usedAbilities: {},
                layout: null,
                turnHistory: [],
                actionsThisTurn: [],
                availableHazards: {
                    tombstone: 4,
                    carcass: 4,
                    'grave-dust': 4,
                    dynamite: 3
                }
            };
            renderSetupScreen();
        }

        window.onload = renderSetupScreen;
    </script>
</body>
</html>
