<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dreadwood Playtest</title>
    <style>
        body {
            background: #333;
            color: #fff;
            text-align: center;
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }
        h1 {
            font-size: 24px;
            margin: 20px 0;
        }
        #setup-screen, #game-screen {
            margin: 20px auto;
            max-width: 90%;
        }
        #setup-screen {
            display: block;
            background: #444;
            padding: 30px;
        }
        #game-screen {
            display: none;
            flex-wrap: wrap;
            justify-content: center;
            align-items: flex-start;
        }
        #game-info {
            background: #444;
            padding: 10px;
            border: 1px solid #000;
            margin: 10px 0;
            width: 100%;
            box-sizing: border-box;
        }
        #actions, #special-actions {
            display: flex;
            flex-direction: row;
            justify-content: center;
            flex-wrap: wrap;
            margin: 10px 0;
            width: 100%;
        }
        .action-icon {
            margin: 5px;
            padding: 5px;
            background: #666;
            border: 1px solid #000;
            font-size: 30px;
            cursor: pointer;
        }
        .action-icon.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .action-separator {
            color: #fff;
            margin: 0 5px;
            font-size: 30px;
        }
        #grid-container {
            position: relative;
            margin: 10px;
        }
        #grid {
            display: grid;
            background: #555;
            padding: 5px;
            border: 1px solid #000;
        }
        .cell {
            background: rgba(85, 85, 85, 0.8);
            border: 0.5px solid #000;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            cursor: pointer;
            position: relative;
            box-sizing: border-box;
        }
        .guardian { font-size: 16px; }
        .guardian.sheriff { background: #fff; }
        .guardian.vigilante { background: #00f; }
        .guardian.outlaw { background: #f00; }
        .guardian.bounty-hunter { background: #0f0; }
        .bloodwell { background: #000; }
        .bloodwell::before { content: 'ü©∏'; font-size: 16px; }
        .tombstone::before { content: 'ü™¶'; }
        .carcass::before { content: 'üíÄ'; }
        .grave-dust::before { content: 'üí©'; }
        .dynamite::before { content: 'üí•'; }
        .cursed { border: 2px solid #800080; }
        .shared .obstacle {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 12px;
        }
        .selected { box-shadow: 0 0 5px 2px #ffff00; }
        .arrow {
            position: absolute;
            background: rgba(255, 255, 255, 0.5);
            font-size: 16px;
            cursor: pointer;
        }
        .arrow:hover {
            background: rgba(255, 255, 255, 0.8);
        }
        #class-info {
            background: #444;
            padding: 10px;
            border: 1px solid #000;
            margin: 10px;
            text-align: left;
            max-width: 300px;
        }
        #class-info h3 {
            margin: 0;
            font-size: 18px;
        }
        #class-info p, #class-info ul {
            color: #000;
            font-size: 14px;
            margin: 5px 0;
        }
        #class-info ul {
            list-style: none;
            padding: 0;
        }
        #class-info li {
            margin: 5px 0;
        }
        #class-info strong {
            color: #000;
        }
        #class-info .used {
            color: #888;
            cursor: default;
        }
        #class-info .active-ability {
            cursor: pointer;
        }
        #class-info .active-ability:hover {
            text-decoration: underline;
        }
        #controls {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            margin: 10px 0;
            width: 100%;
        }
        button {
            margin: 5px;
            padding: 10px 20px;
            background: #666;
            color: #fff;
            border: 1px solid #000;
            border-radius: 5px;
            cursor: pointer;
            font-size: 18px;
            text-transform: uppercase;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        select, input[type="text"] {
            padding: 5px;
            margin: 5px;
            background: #444;
            color: #fff;
            border: 1px solid #000;
            border-radius: 5px;
            font-size: 16px;
        }
        .class-selection {
            margin: 20px 0;
        }
        .class-selection button {
            margin: 2px;
            padding: 8px 12px;
            font-size: 16px;
            border: 2px solid #000;
            border-radius: 5px;
            cursor: pointer;
        }
        .class-selection button.sheriff { background: #00f; color: #fff; }
        .class-selection button.vigilante { background: #333; color: #fff; }
        .class-selection button.outlaw { background: #f00; color: #fff; }
        .class-selection button.bounty-hunter { background: #0f0; color: #fff; }
        .class-selection button.selected {
            outline: 2px solid #ffff00;
            box-shadow: 0 0 5px 2px #ffff00;
        }
        .class-info {
            padding: 15px;
            margin: 30px 0;
            text-align: left;
            color: #fff;
        }
        .class-name {
            font-size: 18px;
            margin: 0;
        }
        .class-description {
            font-size: 16px;
            margin: 5px 0;
        }
        .class-abilities {
            list-style: none;
            padding: 0;
            font-size: 16px;
        }
        .class-abilities li {
            margin: 5px 0;
        }
        .class-abilities strong {
            color: #fff;
        }
        .player-count-buttons {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        label {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 5px;
            display: block;
        }
        #elimination-message, #victory-message {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #444;
            padding: 20px;
            border: 1px solid #000;
            border-radius: 10px;
            font-size: 24px;
            z-index: 1000;
            text-align: center;
        }
        @media (max-width: 600px) {
            #grid {
                grid-template-columns: repeat(9, 40px);
            }
            .cell {
                width: 40px;
                height: 40px;
                font-size: 14px;
            }
            .guardian { font-size: 14px; }
            .bloodwell::before { font-size: 14px; }
            .shared .obstacle { font-size: 10px; }
            .arrow { font-size: 14px; }
            .action-icon { font-size: 24px; }
            #class-info {
                max-width: 100%;
                margin: 10px 0;
            }
            h1 { font-size: 20px; }
            #game-info, .class-description, .class-abilities {
                font-size: 12px;
            }
            button { font-size: 14px; width: 100%; }
            select, input[type="text"] { width: 100%; }
        }
        @media (min-width: 600px) and (max-width: 1200px) {
            #grid {
                grid-template-columns: repeat(9, 45px);
            }
            .cell {
                width: 45px;
                height: 45px;
                font-size: 15px;
            }
            .guardian { font-size: 15px; }
            .bloodwell::before { font-size: 15px; }
            .shared .obstacle { font-size: 11px; }
            .arrow { font-size: 15px; }
            .action-icon { font-size: 30px; }
        }
        @media (min-width: 1200px) {
            #grid {
                grid-template-columns: repeat(9, 50px);
            }
            .cell {
                width: 50px;
                height: 50px;
                font-size: 16px;
            }
            .guardian { font-size: 16px; }
            .bloodwell::before { font-size: 16px; }
            .shared .obstacle { font-size: 12px; }
            .arrow { font-size: 16px; }
            .action-icon { font-size: 40px; }
            h1 { font-size: 24px; }
            #game-info, .class-description, .class-abilities {
                font-size: 14px;
            }
            button { font-size: 16px; }
            input[type="text"] { width: 200px; }
        }
    </style>
</head>
<body>
    <div id="setup-screen">
        <h1>Dreadwood Setup</h1>
        <div id="setup-content"></div>
    </div>

    <div id="game-screen">
        <div id="actions"></div>
        <div id="special-actions"></div>
        <div id="grid-container">
            <div id="grid"></div>
        </div>
        <div id="class-info"></div>
        <div id="game-info">
            <p>Current Player: <span id="current-player">P1</span> | AP Left: <span id="ap-left">4</span> | Turn: <span id="turn">1</span> | Obstacles: <span id="obstacle-count">0</span>/12</p>
        </div>
        <div id="controls">
            <button id="undo-button" onclick="undoTurn()" disabled>Undo</button>
            <button onclick="endTurn()">End Turn</button>
        </div>
    </div>
    <div id="elimination-message"></div>
    <div id="victory-message"></div>

    <script>
        const GRID_SIZE = 9;
        const players = ['P1', 'P2', 'P3', 'P4'];
        const classes = ['Sheriff', 'Vigilante', 'Outlaw', 'Bounty Hunter'];
        const colors = { 'P1': 'white', 'P2': 'blue', 'P3': 'red', 'P4': 'green' };
        const apPerTurn = { 1: 4, 2: 5, 3: 6, 4: 8 };
        let gameState = {
            setupStep: 1,
            currentPlayer: 0,
            turn: 1,
            ap: apPerTurn[1],
            playerCount: 0,
            guardians: {},
            bloodwells: {},
            obstacles: [],
            obstacleCount: 0,
            selectedGuardian: null,
            selectedAction: null,
            playerClasses: {},
            playerNames: {},
            silverSlugs: {},
            cursed: {},
            usedAbilities: {},
            layout: null,
            turnHistory: [],
            actionsThisTurn: []
        };

        const classInfo = {
            'Sheriff': {
                description: 'A vampire lawman enforcing order in a chaotic frontier.',
                abilities: [
                    { name: 'Under My Protection', type: 'passive', description: 'Bloodwells adjacent to a Sheriff‚Äôs Guardian are immune to regular shots.' },
                    { name: 'Swift Justice', type: 'passive', description: 'At the end of the turn, after spending AP, choose one Guardian to move 1 square in its facing direction (0 AP).' },
                    { name: 'Order Restored', type: 'active', cost: 3, description: 'Revive a Guardian, place adjacent to any Guardian or Bloodwell, once per game.' }
                ]
            },
            'Vigilante': {
                description: 'A vampire avenger seeking justice, using teamwork to punish wrongdoers.',
                abilities: [
                    { name: 'Side by Side', type: 'passive', description: 'Split AP between two Guardians each turn.' },
                    { name: 'Blood Brothers', type: 'passive', description: 'If both Guardians are within a 3x3 grid at the start of the turn, gain +1 AP for the turn, provided both use at least 1 AP.' },
                    { name: 'Vengeance is Mine', type: 'active', cost: 0, description: 'Gain 7 AP next turn after a Bloodwell/Guardian is shot, split via Side by Side, once per game.' }
                ]
            },
            'Outlaw': {
                description: 'A vampire bandit thriving on chaos, disrupting and escaping with speed.',
                abilities: [
                    { name: 'Daring Escape', type: 'passive', description: 'After shooting a Bloodwell (3 AP), turn to any direction and move up to 2 squares in that direction (1 AP), once per turn.' },
                    { name: 'Hand Cannon', type: 'active', cost: 5, description: 'Shoot all in one direction up to 5 spaces, ignores obstacles except Under My Protection, once per game.' },
                    { name: 'Rampage', type: 'active', cost: 2, description: 'Shoot left and right of facing direction, once per game.' }
                ]
            },
            'Bounty Hunter': {
                description: 'A vampire mercenary hunting for profit, using precision to eliminate targets.',
                abilities: [
                    { name: 'Sharpshooter', type: 'passive', description: 'Shots ignore Tombstones in their line of sight.' },
                    { name: 'Marked Man', type: 'passive', description: 'Shots on enemy Guardians curse them (move 1, shoot own square only, no throw, clear square to heal), instead of eliminating.' },
                    { name: 'Contract Payoff', type: 'active', cost: 3, description: 'Shoot a Bloodwell; if successful, gain +3 AP next turn (max 8 AP) in 2P, +5 AP (max 10 AP) in 3P/4P, once per game.' }
                ]
            }
        };

        const layouts = {
            '2P': [
                {
                    guardians: {
                        'P1': [{ pos: 'A2', facing: 'S' }, { pos: 'C4', facing: 'S' }],
                        'P2': [{ pos: 'A7', facing: 'N' }, { pos: 'C9', facing: 'N' }]
                    },
                    bloodwells: {
                        'P1': ['B1', 'D3', 'F2'],
                        'P2': ['B6', 'D8', 'F7']
                    },
                    obstacles: [
                        { type: 'Tombstone', pos: 'E5' },
                        { type: 'Carcass', pos: 'D5' },
                        { type: 'Grave Dust', pos: 'F5' },
                        { type: 'Dynamite', pos: 'G5' }
                    ]
                },
                // 25 more layouts generated off-screen
            ],
            '3P': [
                {
                    guardians: {
                        'P1': [{ pos: 'A2', facing: 'S' }, { pos: 'C4', facing: 'S' }],
                        'P2': [{ pos: 'F2', facing: 'S' }, { pos: 'H4', facing: 'S' }],
                        'P3': [{ pos: 'D8', facing: 'N' }, { pos: 'F9', facing: 'N' }]
                    },
                    bloodwells: {
                        'P1': ['B1', 'D3', 'A5'],
                        'P2': ['G1', 'I3', 'G5'],
                        'P3': ['C7', 'E6', 'G8']
                    },
                    obstacles: [
                        { type: 'Tombstone', pos: 'E5' },
                        { type: 'Carcass', pos: 'D5' },
                        { type: 'Grave Dust', pos: 'F5' },
                        { type: 'Dynamite', pos: 'G5' },
                        { type: 'Tombstone', pos: 'H5' }
                    ]
                },
                // 25 more layouts generated off-screen
            ],
            '4P': [
                {
                    guardians: {
                        'P1': [{ pos: 'A2', facing: 'S' }, { pos: 'C4', facing: 'S' }],
                        'P2': [{ pos: 'F2', facing: 'S' }, { pos: 'H4', facing: 'S' }],
                        'P3': [{ pos: 'A7', facing: 'N' }, { pos: 'C9', facing: 'N' }],
                        'P4': [{ pos: 'F7', facing: 'N' }, { pos: 'H9', facing: 'N' }]
                    },
                    bloodwells: {
                        'P1': ['B1', 'D3', 'A3'],
                        'P2': ['G1', 'I3', 'F3'],
                        'P3': ['B6', 'D8', 'A8'],
                        'P4': ['G6', 'I8', 'F8']
                    },
                    obstacles: [
                        { type: 'Tombstone', pos: 'E5' },
                        { type: 'Carcass', pos: 'D5' },
                        { type: 'Grave Dust', pos: 'F5' },
                        { type: 'Dynamite', pos: 'G5' },
                        { type: 'Tombstone', pos: 'E4' },
                        { type: 'Carcass', pos: 'E6' }
                    ]
                },
                // 25 more layouts generated off-screen
            ]
        };

        function renderSetupScreen() {
            const setupContent = document.getElementById('setup-content');
            setupContent.innerHTML = '';
            document.getElementById('game-screen').style.display = 'none';
            document.getElementById('setup-screen').style.display = 'block';

            if (gameState.setupStep === 1) {
                setupContent.innerHTML = `
                    <div class="player-count-buttons">
                        <button onclick="selectPlayerCount(2)">2 Players</button>
                        <button onclick="selectPlayerCount(3)">3 Players</button>
                        <button onclick="selectPlayerCount(4)">4 Players</button>
                    </div>
                `;
            } else if (gameState.setupStep <= gameState.playerCount + 1) {
                const playerNum = gameState.setupStep - 1;
                const player = `P${playerNum}`;
                setupContent.innerHTML = `
                    <h1>Player ${playerNum} Setup</h1>
                    <div class="class-selection">
                        <label>Player ${playerNum} Class:</label>
                        <button class="sheriff" onclick="selectClass('${player}', 'Sheriff')">‚≠ê Sheriff</button>
                        <button class="vigilante" onclick="selectClass('${player}', 'Vigilante')">‚öñÔ∏è Vigilante</button>
                        <button class="outlaw" onclick="selectClass('${player}', 'Outlaw')">üí£ Outlaw</button>
                        <button class="bounty-hunter" onclick="selectClass('${player}', 'Bounty Hunter')">üí∞ Bounty Hunter</button>
                    </div>
                    <div class="class-info" id="class-info-${player}">
                        <p>Select a class to view details.</p>
                    </div>
                    <label for="name-${player}">Player ${playerNum} Name:</label>
                    <input type="text" id="name-${player}" placeholder="${player}" maxlength="20">
                    <button onclick="backStep()">Back</button>
                    <button onclick="nextStep()">Next</button>
                `;
                if (gameState.setupStep === gameState.playerCount + 1) {
                    const nextButton = setupContent.querySelector('button[onclick="nextStep()"]');
                    nextButton.textContent = 'Start Game';
                    nextButton.onclick = startGame;
                }
                const nameInput = document.getElementById(`name-${player}`);
                if (gameState.playerNames[player]) {
                    nameInput.value = gameState.playerNames[player];
                }
                if (gameState.playerClasses[player]) {
                    selectClass(player, gameState.playerClasses[player]);
                }
            }
        }

        function selectPlayerCount(count) {
            gameState.playerCount = count;
            gameState.setupStep = 2;
            renderSetupScreen();
        }

        function selectClass(player, className) {
            gameState.playerClasses[player] = className;
            const buttons = document.querySelectorAll(`button[onclick*="selectClass('${player}'"]`);
            buttons.forEach(button => {
                if (button.textContent.includes(className)) {
                    button.classList.add('selected');
                } else {
                    button.classList.remove('selected');
                }
            });

            const classInfoDiv = document.getElementById(`class-info-${player}`);
            const info = classInfo[className];
            classInfoDiv.innerHTML = `
                <h3 class="class-name">${className}</h3>
                <p class="class-description">${info.description}</p>
                <ul class="class-abilities">
                    ${info.abilities.map(ability => `
                        <li><strong>${ability.name}${ability.cost ? ` (${ability.cost} AP)` : ''}:</strong> ${ability.description}</li>
                    `).join('')}
                </ul>
            `;
        }

        function nextStep() {
            const playerNum = gameState.setupStep - 1;
            const player = `P${playerNum}`;
            if (!gameState.playerClasses[player]) {
                alert(`Please select a class for Player ${playerNum}!`);
                return;
            }
            const nameInput = document.getElementById(`name-${player}`).value.trim();
            gameState.playerNames[player] = nameInput || player;

            gameState.setupStep++;
            renderSetupScreen();
        }

        function backStep() {
            gameState.setupStep--;
            if (gameState.setupStep < 1) gameState.setupStep = 1;
            renderSetupScreen();
        }

        function startGame() {
            const playerNum = gameState.setupStep - 1;
            const player = `P${playerNum}`;
            if (!gameState.playerClasses[player]) {
                alert(`Please select a class for Player ${playerNum}!`);
                return;
            }
            const nameInput = document.getElementById(`name-${player}`).value.trim();
            gameState.playerNames[player] = nameInput || player;

            const layoutIndex = Math.floor(Math.random() * 26);
            const layout = layouts[`${gameState.playerCount}P`][layoutIndex];
            gameState.layout = layout;
            gameState.guardians = {};
            gameState.bloodwells = {};
            gameState.obstacles = layout.obstacles;
            gameState.obstacleCount = layout.obstacles.length;

            for (let i = 1; i <= gameState.playerCount; i++) {
                const p = `P${i}`;
                gameState.guardians[p] = layout.guardians[p].map((g, idx) => ({
                    id: `${p}G${idx + 1}`,
                    pos: g.pos,
                    facing: g.facing,
                    alive: true
                }));
                gameState.bloodwells[p] = layout.bloodwells[p];
                gameState.silverSlugs[p] = 1;
                gameState.cursed[`${p}G1`] = false;
                gameState.cursed[`${p}G2`] = false;
                gameState.usedAbilities[p] = {};
            }

            if (gameState.playerCount === 4) {
                const p4Well = prompt(`${gameState.playerNames['P4']}: Place free Tombstone adjacent to a Bloodwell (e.g., I7 next to I8):`, "I7");
                gameState.obstacles.push({ type: 'Tombstone', pos: p4Well });
                gameState.obstacleCount++;
            }

            document.getElementById('setup-screen').style.display = 'none';
            document.getElementById('game-screen').style.display = 'flex';
            renderGrid();
            updateGameInfo();
            updateClassInfo();
            updateActionIcons();
        }

        function renderGrid() {
            const grid = document.getElementById('grid');
            grid.innerHTML = '';
            for (let row = 1; row <= GRID_SIZE; row++) {
                for (let col = 1; col <= GRID_SIZE; col++) {
                    const pos = String.fromCharCode(64 + col) + row;
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.id = pos;
                    cell.onclick = () => selectCell(pos);

                    let content = '';
                    let hasGuardian = false;
                    let hasObstacle = false;
                    let obstacleType = '';

                    for (let player in gameState.guardians) {
                        const guardian = gameState.guardians[player].find(g => g.pos === pos && g.alive);
                        if (guardian) {
                            content = '‚ôüÔ∏è';
                            cell.classList.add('guardian');
                            cell.classList.add(gameState.playerClasses[player].toLowerCase());
                            if (gameState.cursed[guardian.id]) cell.classList.add('cursed');
                            hasGuardian = true;
                            break;
                        }
                    }

                    if (!hasGuardian) {
                        for (let player in gameState.bloodwells) {
                            if (gameState.bloodwells[player].includes(pos)) {
                                content = '';
                                cell.classList.add('bloodwell');
                                cell.classList.add(gameState.playerClasses[player].toLowerCase());
                                break;
                            }
                        }
                    }

                    const obstacle = gameState.obstacles.find(o => o.pos === pos);
                    if (obstacle) {
                        hasObstacle = true;
                        obstacleType = obstacle.type.toLowerCase().replace(' ', '-');
                        if (!hasGuardian) {
                            content = '';
                            cell.classList.add(obstacleType);
                        }
                    }

                    if (hasGuardian && hasObstacle) {
                        cell.classList.add('shared');
                        const obstacleSpan = document.createElement('span');
                        obstacleSpan.className = `obstacle ${obstacleType}`;
                        cell.appendChild(obstacleSpan);
                    }

                    cell.innerHTML += content;
                    grid.appendChild(cell);
                }
            }

            if (gameState.selectedGuardian) {
                const pos = gameState.selectedGuardian.pos;
                const cell = document.getElementById(pos);
                cell.classList.add('selected');

                const [col, row] = [pos.charCodeAt(0) - 64, parseInt(pos[1])];
                const directions = [
                    { dir: 'N', pos: `${String.fromCharCode(64 + col)}${row - 1}`, emoji: '‚¨ÜÔ∏è' },
                    { dir: 'S', pos: `${String.fromCharCode(64 + col)}${row + 1}`, emoji: '‚¨áÔ∏è' },
                    { dir: 'E', pos: `${String.fromCharCode(64 + col + 1)}${row}`, emoji: '‚û°Ô∏è' },
                    { dir: 'W', pos: `${String.fromCharCode(64 + col - 1)}${row}`, emoji: '‚¨ÖÔ∏è' }
                ];

                directions.forEach(({ dir, pos, emoji }) => {
                    if (row > 1 && dir === 'N' || row < GRID_SIZE && dir === 'S' || col > 1 && dir === 'W' || col < GRID_SIZE && dir === 'E') {
                        const arrowCell = document.getElementById(pos);
                        if (arrowCell) {
                            const arrow = document.createElement('div');
                            arrow.className = 'arrow';
                            arrow.innerHTML = emoji;
                            arrow.onclick = () => handleArrowClick(dir);
                            arrowCell.appendChild(arrow);
                        }
                    }
                });
            }
        }

        function updateActionIcons() {
            const actionsDiv = document.getElementById('actions');
            const specialActionsDiv = document.getElementById('special-actions');
            actionsDiv.innerHTML = `
                <div class="action-icon" onclick="selectAction('shoot')">üî´</div>
                <span class="action-separator">|</span>
                <div class="action-icon" onclick="selectThrow('Tombstone')">ü™¶</div>
                <span class="action-separator">|</span>
                <div class="action-icon" onclick="selectThrow('Carcass')">üíÄ</div>
                <span class="action-separator">|</span>
                <div class="action-icon" onclick="selectThrow('Grave Dust')">üí©</div>
                <span class="action-separator">|</span>
                <div class="action-icon" onclick="selectThrow('Dynamite')">üí•</div>
            `;

            let specialActions = [];
            if (gameState.selectedGuardian) {
                const pos = gameState.selectedGuardian.pos;
                const obstacle = gameState.obstacles.find(o => o.pos === pos);
                if (obstacle && obstacle.type === 'Dynamite') {
                    specialActions.push(`<div class="action-icon" onclick="selectAction('bite')">üçΩÔ∏èüí•ü§¢</div>`);
                }
                if (obstacle && obstacle.type === 'Grave Dust') {
                    specialActions.push(`<div class="action-icon" onclick="selectAction('dispel')">ü™Ñ</div>`);
                }
            }

            const player = players[gameState.currentPlayer];
            if (!gameState.usedAbilities[player]?.['Blood Ritual']) {
                specialActions.push(`<div class="action-icon" onclick="selectAction('bloodRitual')">ü©∏ü™Ñ</div>`);
            }

            const className = gameState.playerClasses[player];
            if (className === 'Sheriff' && !gameState.usedAbilities[player]?.['Order Restored']) {
                specialActions.push(`<div class="action-icon" onclick="selectAbility('Order Restored')">‚≠ê‚ûï</div>`);
            } else if (className === 'Vigilante' && !gameState.usedAbilities[player]?.['Vengeance is Mine']) {
                specialActions.push(`<div class="action-icon" onclick="selectAbility('Vengeance is Mine')">‚öñÔ∏èüòè</div>`);
            } else if (className === 'Outlaw') {
                if (!gameState.usedAbilities[player]?.['Hand Cannon']) {
                    specialActions.push(`<div class="action-icon" onclick="selectAbility('Hand Cannon')">üöÄ</div>`);
                }
                if (!gameState.usedAbilities[player]?.['Rampage']) {
                    specialActions.push(`<div class="action-icon" onclick="selectAbility('Rampage')"><span style="color: #ff4500;">‚è™</span>üò°<span style="color: #ff4500;">‚è©</span></div>`);
                }
            } else if (className === 'Bounty Hunter' && !gameState.usedAbilities[player]?.['Contract Payoff']) {
                specialActions.push(`<div class="action-icon" onclick="selectAbility('Contract Payoff')">üìúüí∞</div>`);
            }

            if (gameState.silverSlugs[player] > 0) {
                specialActions.push(`<div class="action-icon" onclick="selectAction('silverSlug')">üî´üíé</div>`);
            }

            specialActionsDiv.innerHTML = specialActions.join('<span class="action-separator">|</span>');
        }

        function selectCell(pos) {
            const player = players[gameState.currentPlayer];
            const guardian = gameState.guardians[player].find(g => g.pos === pos && g.alive);
            if (guardian) {
                gameState.selectedGuardian = guardian;
                gameState.selectedAction = null;
                renderGrid();
                updateClassInfo();
                updateActionIcons();
            } else if (gameState.selectedGuardian && gameState.selectedAction) {
                executeAction(pos);
            }
        }

        function selectAction(action) {
            gameState.selectedAction = action;
            renderGrid();
            updateActionIcons();
        }

        function selectThrow(obstacle) {
            gameState.selectedAction = 'throw';
            gameState.selectedObstacle = obstacle;
            renderGrid();
        }

        function selectAbility(abilityName) {
            const player = players[gameState.currentPlayer];
            if (confirm(`${abilityName} can only be used once per game. Are you sure?`)) {
                gameState.selectedAction = 'ability';
                gameState.selectedAbility = abilityName;
                renderGrid();
            }
        }

        function handleArrowClick(direction) {
            if (!gameState.selectedGuardian) return;
            const guardian = gameState.selectedGuardian;
            if (gameState.cursed[guardian.id]) {
                alert("This Guardian is cursed and cannot move or turn!");
                return;
            }

            if (guardian.facing === direction) {
                gameState.selectedAction = 'move';
            } else {
                gameState.selectedAction = 'turn';
                gameState.selectedDirection = direction;
            }
            const [col, row] = [guardian.pos.charCodeAt(0) - 64, parseInt(guardian.pos[1])];
            let targetPos;
            if (direction === 'N') targetPos = `${String.fromCharCode(64 + col)}${row - 1}`;
            if (direction === 'S') targetPos = `${String.fromCharCode(64 + col)}${row + 1}`;
            if (direction === 'E') targetPos = `${String.fromCharCode(64 + col + 1)}${row}`;
            if (direction === 'W') targetPos = `${String.fromCharCode(64 + col - 1)}${row}`;
            executeAction(targetPos);
        }

        function executeAction(targetPos) {
            const player = players[gameState.currentPlayer];
            const guardian = gameState.selectedGuardian;
            const action = gameState.selectedAction;
            let apCost = 0;

            const currentState = JSON.parse(JSON.stringify({
                guardians: gameState.guardians,
                bloodwells: gameState.bloodwells,
                obstacles: gameState.obstacles,
                obstacleCount: gameState.obstacleCount,
                cursed: gameState.cursed,
                usedAbilities: gameState.usedAbilities,
                ap: gameState.ap,
                silverSlugs: gameState.silverSlugs
            }));
            gameState.actionsThisTurn.push(currentState);

            if (action === 'move') {
                apCost = 1;
                if (gameState.ap >= apCost) {
                    const newPos = canMove(guardian, targetPos);
                    if (newPos) {
                        guardian.pos = targetPos;
                        gameState.ap -= apCost;
                        alert(`${gameState.playerNames[player]}'s ${guardian.id} moved to ${targetPos}`);
                    }
                }
            } else if (action === 'turn') {
                apCost = 1;
                if (gameState.ap >= apCost) {
                    guardian.facing = gameState.selectedDirection;
                    gameState.ap -= apCost;
                    alert(`${gameState.playerNames[player]}'s ${guardian.id} turned to face ${guardian.facing}`);
                }
            } else if (action === 'shoot') {
                apCost = 3;
                if (gameState.ap >= apCost) {
                    const target = canShoot(guardian, targetPos);
                    if (target) {
                        handleShot(guardian, targetPos);
                        gameState.ap -= apCost;
                    }
                }
            } else if (action === 'throw') {
                const obstacleType = gameState.selectedObstacle;
                apCost = obstacleType === 'Dynamite' ? 2 : 1;
                if (gameState.ap >= apCost && gameState.obstacleCount < 12) {
                    const canThrow = canThrowObstacle(guardian, targetPos, obstacleType);
                    if (canThrow) {
                        gameState.obstacles.push({ type: obstacleType, pos: targetPos });
                        gameState.obstacleCount++;
                        gameState.ap -= apCost;
                        alert(`${gameState.playerNames[player]}'s ${guardian.id} threw ${obstacleType} to ${targetPos}`);
                    }
                } else if (gameState.obstacleCount >= 12) {
                    alert("Obstacle limit (12) reached!");
                }
            } else if (action === 'dispel') {
                apCost = 3;
                if (gameState.ap >= apCost) {
                    const pos = guardian.pos;
                    const obstacle = gameState.obstacles.find(o => o.pos === pos && o.type === 'Grave Dust');
                    if (obstacle) {
                        gameState.obstacles = gameState.obstacles.filter(o => o !== obstacle);
                        gameState.obstacleCount--;
                        gameState.ap -= apCost;
                        alert(`${gameState.playerNames[player]}'s ${guardian.id} dispelled the Grave Dust at ${pos}`);
                    }
                }
            } else if (action === 'bite') {
                apCost = 1;
                if (gameState.ap >= apCost) {
                    const pos = guardian.pos;
                    const obstacle = gameState.obstacles.find(o => o.pos === pos && o.type === 'Dynamite');
                    if (obstacle) {
                        gameState.obstacles = gameState.obstacles.filter(o => o !== obstacle);
                        gameState.obstacleCount--;
                        gameState.cursed[guardian.id] = true;
                        gameState.ap -= apCost;
                        alert(`${gameState.playerNames[player]}'s ${guardian.id} bit the fuse at ${pos} and is now cursed!`);
                    }
                }
            } else if (action === 'bloodRitual') {
                apCost = 3;
                if (gameState.ap >= apCost) {
                    const target = canShoot(guardian, targetPos);
                    if (target && gameState.bloodwells[player].includes(targetPos)) {
                        gameState.bloodwells[player] = gameState.bloodwells[player].filter(pos => pos !== targetPos);
                        const deadGuardian = gameState.guardians[player].find(g => !g.alive);
                        if (deadGuardian) {
                            deadGuardian.alive = true;
                            deadGuardian.pos = targetPos;
                            gameState.ap -= apCost;
                            gameState.usedAbilities[player]['Blood Ritual'] = true;
                            alert(`${gameState.playerNames[player]} used Blood Ritual: Sacrificed a Bloodwell at ${targetPos} to revive ${deadGuardian.id}`);
                        } else {
                            alert("No dead Guardians to revive!");
                            gameState.actionsThisTurn.pop();
                            return;
                        }
                    } else {
                        alert("Blood Ritual requires shooting your own Bloodwell!");
                        gameState.actionsThisTurn.pop();
                        return;
                    }
                }
            } else if (action === 'silverSlug') {
                apCost = 3;
                if (gameState.ap >= apCost && gameState.silverSlugs[player] > 0) {
                    const target = canShoot(guardian, targetPos);
                    if (target) {
                        for (let p in gameState.guardians) {
                            const targetGuardian = gameState.guardians[p].find(g => g.pos === targetPos && g.alive);
                            if (targetGuardian && p !== player) {
                                targetGuardian.alive = false;
                                gameState.silverSlugs[player]--;
                                gameState.ap -= apCost;
                                alert(`${gameState.playerNames[player]}'s ${guardian.id} used a Silver Slug to eliminate ${gameState.playerNames[p]}'s ${targetGuardian.id} at ${targetPos}`);
                                break;
                            }
                        }
                    }
                }
            } else if (action === 'ability') {
                const ability = gameState.selectedAbility;
                if (ability === 'Order Restored') {
                    apCost = 3;
                    if (gameState.ap >= apCost) {
                        const deadGuardian = gameState.guardians[player].find(g => !g.alive);
                        if (deadGuardian) {
                            deadGuardian.alive = true;
                            deadGuardian.pos = targetPos;
                            gameState.ap -= apCost;
                            gameState.usedAbilities[player]['Order Restored'] = true;
                            alert(`${gameState.playerNames[player]} used Order Restored: Revived ${deadGuardian.id} at ${targetPos}`);
                        } else {
                            alert("No dead Guardians to revive!");
                            gameState.actionsThisTurn.pop();
                            return;
                        }
                    }
                } else if (ability === 'Vengeance is Mine') {
                    alert("Vengeance is Mine triggers on opponent shot!");
                    gameState.actionsThisTurn.pop();
                    return;
                } else if (ability === 'Hand Cannon') {
                    apCost = 5;
                    if (gameState.ap >= apCost) {
                        const direction = prompt("Choose direction for Hand Cannon (N, S, E, W):", guardian.facing);
                        if (['N', 'S', 'E', 'W'].includes(direction)) {
                            handleHandCannon(guardian, direction);
                            gameState.ap -= apCost;
                            gameState.usedAbilities[player]['Hand Cannon'] = true;
                        } else {
                            alert("Invalid direction!");
                            gameState.actionsThisTurn.pop();
                            return;
                        }
                    }
                } else if (ability === 'Rampage') {
                    apCost = 2;
                    if (gameState.ap >= apCost) {
                        handleRampage(guardian);
                        gameState.ap -= apCost;
                        gameState.usedAbilities[player]['Rampage'] = true;
                    }
                } else if (ability === 'Contract Payoff') {
                    apCost = 3;
                    if (gameState.ap >= apCost) {
                        const target = canShoot(guardian, targetPos);
                        if (target && target.includes('B')) {
                            gameState.bloodwells[player].includes(targetPos) ? gameState.bloodwells[player] = gameState.bloodwells[player].filter(pos => pos !== targetPos) : null;
                            gameState.ap -= apCost;
                            gameState.usedAbilities[player]['Contract Payoff'] = true;
                            alert(`${gameState.playerNames[player]} used Contract Payoff: Shot ${target}, +${gameState.playerCount === 2 ? 3 : 5} AP next turn`);
                            // AP boost logic handled in endTurn
                        } else {
                            alert("Contract Payoff requires shooting a Bloodwell!");
                            gameState.actionsThisTurn.pop();
                            return;
                        }
                    }
                }
            }

            gameState.selectedGuardian = null;
            gameState.selectedAction = null;
            renderGrid();
            updateGameInfo();
            updateClassInfo();
            updateActionIcons();
            checkGameState();
            document.getElementById('undo-button').disabled = gameState.actionsThisTurn.length === 0;
        }

        function canMove(guardian, targetPos) {
            const [targetCol, targetRow] = [targetPos.charCodeAt(0) - 64, parseInt(targetPos[1])];
            const [currentCol, currentRow] = [guardian.pos.charCodeAt(0) - 64, parseInt(guardian.pos[1])];
            const direction = guardian.facing;
            if (direction === 'N' && targetRow < currentRow && targetCol === currentCol) return true;
            if (direction === 'S' && targetRow > currentRow && targetCol === currentCol) return true;
            if (direction === 'E' && targetCol > currentCol && targetRow === currentRow) return true;
            if (direction === 'W' && targetCol < currentCol && targetRow === currentRow) return true;
            alert("Invalid move direction!");
            return false;
        }

        function canShoot(guardian, targetPos) {
            const [targetCol, targetRow] = [targetPos.charCodeAt(0) - 64, parseInt(targetPos[1])];
            const [currentCol, currentRow] = [guardian.pos.charCodeAt(0) - 64, parseInt(guardian.pos[1])];
            const direction = guardian.facing;
            let path = [];
            if (direction === 'N' && targetCol === currentCol && targetRow < currentRow) {
                for (let r = currentRow - 1; r >= targetRow; r--) path.push(`${String.fromCharCode(64 + currentCol)}${r}`);
            } else if (direction === 'S' && targetCol === currentCol && targetRow > currentRow) {
                for (let r = currentRow + 1; r <= targetRow; r++) path.push(`${String.fromCharCode(64 + currentCol)}${r}`);
            } else if (direction === 'E' && targetRow === currentRow && targetCol > currentCol) {
                for (let c = currentCol + 1; c <= targetCol; c++) path.push(`${String.fromCharCode(64 + c)}${currentRow}`);
            } else if (direction === 'W' && targetRow === currentRow && targetCol < currentCol) {
                for (let c = currentCol - 1; c >= targetCol; c++) path.push(`${String.fromCharCode(64 + c)}${currentRow}`);
            } else {
                alert("Invalid shot direction!");
                return null;
            }

            for (let pos of path.slice(0, -1)) {
                const obstacle = gameState.obstacles.find(o => o.pos === pos);
                if (obstacle) {
                    if (gameState.playerClasses[players[gameState.currentPlayer]] === 'Bounty Hunter' && obstacle.type === 'Tombstone') {
                        continue;
                    }
                    if (obstacle.type !== 'Grave Dust') {
                        alert("Shot blocked by obstacle!");
                        return null;
                    }
                }
            }

            for (let player in gameState.guardians) {
                const targetGuardian = gameState.guardians[player].find(g => g.pos === path[path.length - 1] && g.alive);
                if (targetGuardian && gameState.playerClasses[player] === 'Sheriff') {
                    for (let bloodwell of gameState.bloodwells[player]) {
                        const [bCol, bRow] = [bloodwell.charCodeAt(0) - 64, parseInt(bloodwell[1])];
                        if (Math.abs(bCol - targetCol) <= 1 && Math.abs(bRow - targetRow) <= 1) {
                            alert("Shot blocked by Under My Protection!");
                            return null;
                        }
                    }
                }
            }

            return path[path.length - 1];
        }

        function handleShot(guardian, targetPos) {
            const player = players[gameState.currentPlayer];
            const target = gameState.bloodwells[player].includes(targetPos) ? `${player}B` : null;
            if (target) {
                alert("Cannot shoot your own Bloodwell!");
                gameState.actionsThisTurn.pop();
                return;
            }

            for (let p in gameState.bloodwells) {
                if (p !== player && gameState.bloodwells[p].includes(targetPos)) {
                    gameState.bloodwells[p] = gameState.bloodwells[p].filter(pos => pos !== targetPos);
                    alert(`${gameState.playerNames[player]}'s ${guardian.id} shot ${gameState.playerNames[p]}'s Bloodwell at ${targetPos}`);
                    if (gameState.playerClasses[p] === 'Vigilante') {
                        alert(`${gameState.playerNames[p]} triggers Vengeance is Mine: +7 AP next turn`);
                        gameState.usedAbilities[p]['Vengeance is Mine'] = true;
                    }
                    if (gameState.playerClasses[player] === 'Outlaw') {
                        gameState.selectedAction = 'daringEscape';
                        renderGrid();
                    }
                    return;
                }
            }

            for (let p in gameState.guardians) {
                const targetGuardian = gameState.guardians[p].find(g => g.pos === targetPos && g.alive);
                if (targetGuardian) {
                    if (gameState.playerClasses[player] === 'Bounty Hunter') {
                        gameState.cursed[targetGuardian.id] = true;
                        alert(`${gameState.playerNames[player]}'s ${guardian.id} cursed ${gameState.playerNames[p]}'s ${targetGuardian.id} with Marked Man`);
                    } else {
                        alert("Shot ignored‚Äîuse silver slug to eliminate!");
                    }
                    return;
                }
            }

            const obstacle = gameState.obstacles.find(o => o.pos === targetPos);
            if (obstacle) {
                if (obstacle.type === 'Dynamite') {
                    handleDynamiteExplosion(targetPos);
                } else {
                    gameState.obstacles = gameState.obstacles.filter(o => o.pos !== targetPos);
                    gameState.obstacleCount--;
                    alert(`${gameState.playerNames[player]}'s ${guardian.id} destroyed ${obstacle.type} at ${targetPos}`);
                }
            }
        }

        function handleDynamiteExplosion(pos) {
            const [col, row] = [pos.charCodeAt(0) - 64, parseInt(pos[1])];
            const radius = 3;
            const affected = [];
            for (let r = Math.max(1, row - 1); r <= Math.min(9, row + 1); r++) {
                for (let c = Math.max(1, col - 1); c <= Math.min(9, col + 1); c++) {
                    affected.push(`${String.fromCharCode(64 + c)}${r}`);
                }
            }

            gameState.obstacles = gameState.obstacles.filter(o => o.pos !== pos);
            gameState.obstacleCount--;
            alert(`Dynamite exploded at ${pos}, affecting ${affected.length} squares`);

            for (let p in gameState.bloodwells) {
                gameState.bloodwells[p] = gameState.bloodwells[p].filter(b => !affected.includes(b));
                if (gameState.bloodwells[p].length === 0) {
                    showEliminationMessage(p);
                }
            }
        }

        function canThrowObstacle(guardian, targetPos, type) {
            const [targetCol, targetRow] = [targetPos.charCodeAt(0) - 64, parseInt(targetPos[1])];
            const [currentCol, currentRow] = [guardian.pos.charCodeAt(0) - 64, parseInt(guardian.pos[1])];
            const direction = guardian.facing;
            let path = [];
            if (direction === 'N' && targetCol === currentCol && targetRow < currentRow) {
                for (let r = currentRow - 1; r >= targetRow; r--) path.push(`${String.fromCharCode(64 + currentCol)}${r}`);
            } else if (direction === 'S' && targetCol === currentCol && targetRow > currentRow) {
                for (let r = currentRow + 1; r <= targetRow; r++) path.push(`${String.fromCharCode(64 + currentCol)}${r}`);
            } else if (direction === 'E' && targetRow === currentRow && targetCol > currentCol) {
                for (let c = currentCol + 1; c <= targetCol; c++) path.push(`${String.fromCharCode(64 + c)}${currentRow}`);
            } else if (direction === 'W' && targetRow === currentRow && targetCol < currentCol) {
                for (let c = currentCol - 1; c >= targetCol; c++) path.push(`${String.fromCharCode(64 + c)}${currentRow}`);
            } else {
                alert("Invalid throw direction!");
                return false;
            }

            if (path.length > 3) {
                alert("Throw distance exceeds 3 squares!");
                return false;
            }

            for (let pos of path.slice(0, -1)) {
                if (gameState.obstacles.some(o => o.pos === pos) || Object.values(gameState.guardians).flat().some(g => g.pos === pos && g.alive)) {
                    alert("Throw path blocked!");
                    return false;
                }
            }

            const targetOccupied = Object.values(gameState.guardians).flat().some(g => g.pos === targetPos && g.alive) || gameState.obstacles.some(o => o.pos === targetPos);
            if (type === 'Grave Dust' && targetOccupied) {
                const targetGuardian = Object.values(gameState.guardians).flat().find(g => g.pos === targetPos && g.alive);
                if (targetGuardian) {
                    gameState.cursed[targetGuardian.id] = true;
                    alert(`${guardian.id} cursed ${targetGuardian.id} with Grave Dust`);
                    return false;
                }
            } else if (targetOccupied) {
                alert("Target square occupied!");
                return false;
            }

            return true;
        }

        function handleHandCannon(guardian, direction) {
            const [currentCol, currentRow] = [guardian.pos.charCodeAt(0) - 64, parseInt(guardian.pos[1])];
            let path = [];
            if (direction === 'N') {
                for (let r = currentRow - 1; r >= Math.max(1, currentRow - 5); r--) path.push(`${String.fromCharCode(64 + currentCol)}${r}`);
            } else if (direction === 'S') {
                for (let r = currentRow + 1; r <= Math.min(9, currentRow + 5); r++) path.push(`${String.fromCharCode(64 + currentCol)}${r}`);
            } else if (direction === 'E') {
                for (let c = currentCol + 1; c <= Math.min(9, currentCol + 5); c++) path.push(`${String.fromCharCode(64 + c)}${currentRow}`);
            } else if (direction === 'W') {
                for (let c = currentCol - 1; c >= Math.max(1, currentCol - 5); c++) path.push(`${String.fromCharCode(64 + c)}${currentRow}`);
            }

            for (let pos of path) {
                for (let p in gameState.bloodwells) {
                    if (gameState.bloodwells[p].includes(pos)) {
                        gameState.bloodwells[p] = gameState.bloodwells[p].filter(b => b !== pos);
                        alert(`${gameState.playerNames[players[gameState.currentPlayer]]}'s ${guardian.id} Hand Cannon hit ${gameState.playerNames[p]}'s Bloodwell at ${pos}`);
                    }
                }
                const obstacle = gameState.obstacles.find(o => o.pos === pos);
                if (obstacle) {
                    if (obstacle.type === 'Dynamite') {
                        handleDynamiteExplosion(pos);
                    } else {
                        gameState.obstacles = gameState.obstacles.filter(o => o.pos !== pos);
                        gameState.obstacleCount--;
                        alert(`${gameState.playerNames[players[gameState.currentPlayer]]}'s ${guardian.id} Hand Cannon destroyed ${obstacle.type} at ${pos}`);
                    }
                }
            }
        }

        function handleRampage(guardian) {
            const [col, row] = [guardian.pos.charCodeAt(0) - 64, parseInt(guardian.pos[1])];
            const direction = guardian.facing;
            let leftPos, rightPos;
            if (direction === 'N' || direction === 'S') {
                leftPos = col > 1 ? `${String.fromCharCode(64 + col - 1)}${row}` : null;
                rightPos = col < 9 ? `${String.fromCharCode(64 + col + 1)}${row}` : null;
            } else {
                leftPos = row > 1 ? `${String.fromCharCode(64 + col)}${row - 1}` : null;
                rightPos = row < 9 ? `${String.fromCharCode(64 + col)}${row + 1}` : null;
            }

            [leftPos, rightPos].forEach(pos => {
                if (pos) {
                    for (let p in gameState.bloodwells) {
                        if (gameState.bloodwells[p].includes(pos)) {
                            gameState.bloodwells[p] = gameState.bloodwells[p].filter(b => b !== pos);
                            alert(`${gameState.playerNames[players[gameState.currentPlayer]]}'s ${guardian.id} Rampage hit ${gameState.playerNames[p]}'s Bloodwell at ${pos}`);
                        }
                    }
                    const obstacle = gameState.obstacles.find(o => o.pos === pos);
                    if (obstacle) {
                        if (obstacle.type === 'Dynamite') {
                            handleDynamiteExplosion(pos);
                        } else {
                            gameState.obstacles = gameState.obstacles.filter(o => o.pos !== pos);
                            gameState.obstacleCount--;
                            alert(`${gameState.playerNames[players[gameState.currentPlayer]]}'s ${guardian.id} Rampage destroyed ${obstacle.type} at ${pos}`);
                        }
                    }
                }
            });
        }

        function endTurn() {
            const player = players[gameState.currentPlayer];
            if (gameState.playerClasses[player] === 'Sheriff') {
                const guardian = gameState.guardians[player].find(g => g.alive);
                if (guardian) {
                    const [col, row] = [guardian.pos.charCodeAt(0) - 64, parseInt(guardian.pos[1])];
                    let targetPos;
                    if (guardian.facing === 'N' && row > 1) targetPos = `${String.fromCharCode(64 + col)}${row - 1}`;
                    if (guardian.facing === 'S' && row < GRID_SIZE) targetPos = `${String.fromCharCode(64 + col)}${row + 1}`;
                    if (guardian.facing === 'E' && col < GRID_SIZE) targetPos = `${String.fromCharCode(64 + col + 1)}${row}`;
                    if (guardian.facing === 'W' && col > 1) targetPos = `${String.fromCharCode(64 + col - 1)}${row}`;
                    if (targetPos && canMove(guardian, targetPos)) {
                        guardian.pos = targetPos;
                        alert(`${gameState.playerNames[player]}'s ${guardian.id} moved to ${targetPos} via Swift Justice`);
                    }
                }
            }

            gameState.currentPlayer = (gameState.currentPlayer + 1) % gameState.playerCount;
            gameState.turn++;
            gameState.ap = apPerTurn[gameState.currentPlayer + 1];
            if (gameState.playerClasses[players[gameState.currentPlayer]] === 'Vigilante') {
                const g1 = gameState.guardians[players[gameState.currentPlayer]][0];
                const g2 = gameState.guardians[players[gameState.currentPlayer]][1];
                const [col1, row1] = [g1.pos.charCodeAt(0) - 64, parseInt(g1.pos[1])];
                const [col2, row2] = [g2.pos.charCodeAt(0) - 64, parseInt(g2.pos[1])];
                if (Math.abs(col1 - col2) <= 2 && Math.abs(row1 - row2) <= 2) {
                    gameState.ap += 1;
                    gameState.bloodBrothersActive = true;
                } else {
                    gameState.bloodBrothersActive = false;
                }
            }
            if (gameState.usedAbilities[players[gameState.currentPlayer]]?.['Contract Payoff']) {
                gameState.ap += gameState.playerCount === 2 ? 3 : 5;
                gameState.ap = Math.min(gameState.ap, gameState.playerCount === 2 ? 8 : 10);
                delete gameState.usedAbilities[players[gameState.currentPlayer]]['Contract Payoff'];
            }
            gameState.selectedGuardian = null;
            gameState.selectedAction = null;
            gameState.actionsThisTurn = [];
            gameState.turnHistory = [];
            document.getElementById('undo-button').disabled = true;
            alert(`Turn ended. Now ${gameState.playerNames[players[gameState.currentPlayer]]}'s turn.`);
            renderGrid();
            updateGameInfo();
            updateClassInfo();
            updateActionIcons();
        }

        function undoTurn() {
            if (gameState.actionsThisTurn.length === 0) return;
            const lastState = gameState.actionsThisTurn.pop();
            gameState.guardians = JSON.parse(JSON.stringify(lastState.guardians));
            gameState.bloodwells = JSON.parse(JSON.stringify(lastState.bloodwells));
            gameState.obstacles = JSON.parse(JSON.stringify(lastState.obstacles));
            gameState.obstacleCount = lastState.obstacleCount;
            gameState.cursed = JSON.parse(JSON.stringify(lastState.cursed));
            gameState.usedAbilities = JSON.parse(JSON.stringify(lastState.usedAbilities));
            gameState.ap = lastState.ap;
            gameState.silverSlugs = JSON.parse(JSON.stringify(lastState.silverSlugs));
            gameState.selectedGuardian = null;
            gameState.selectedAction = null;
            renderGrid();
            updateGameInfo();
            updateClassInfo();
            updateActionIcons();
            document.getElementById('undo-button').disabled = gameState.actionsThisTurn.length === 0;
        }

        function updateGameInfo() {
            document.getElementById('current-player').textContent = gameState.playerNames[players[gameState.currentPlayer]];
            document.getElementById('ap-left').textContent = gameState.ap;
            document.getElementById('turn').textContent = gameState.turn;
            document.getElementById('obstacle-count').textContent = gameState.obstacleCount;
        }

        function updateClassInfo() {
            const player = players[gameState.currentPlayer];
            const className = gameState.playerClasses[player];
            const info = classInfo[className];
            const classInfoDiv = document.getElementById('class-info');
            classInfoDiv.innerHTML = `
                <h3 class="class-name">${className}</h3>
                <p class="class-description">${info.description}</p>
                <ul class="class-abilities">
                    ${info.abilities.map(ability => `
                        <li class="${ability.type === 'active' && gameState.usedAbilities[player]?.[ability.name] ? 'used' : ''} ${ability.type === 'active' && !gameState.usedAbilities[player]?.[ability.name] ? 'active-ability' : ''}" 
                            onclick="${ability.type === 'active' && !gameState.usedAbilities[player]?.[ability.name] ? `selectAbility('${ability.name}')` : ''}">
                            <strong>${ability.name}${ability.cost ? ` (${ability.cost} AP)` : ''}:</strong> ${ability.description}
                        </li>
                    `).join('')}
                </ul>
            `;
        }

        function showEliminationMessage(player) {
            const messageDiv = document.getElementById('elimination-message');
            messageDiv.textContent = `Player Eliminated! ${gameState.playerNames[player]} has been eliminated from the game.`;
            messageDiv.style.display = 'block';
            setTimeout(() => {
                messageDiv.style.display = 'none';
                checkGameState();
            }, 3000);
        }

        function showVictoryMessage(winner) {
            const messageDiv = document.getElementById('victory-message');
            messageDiv.innerHTML = `
                Victory! ${gameState.playerNames[winner]} Wins! All enemy Bloodwells destroyed.
                <button onclick="restartGame()">Restart Game</button>
            `;
            messageDiv.style.display = 'block';
        }

        function checkGameState() {
            const remainingPlayers = players.slice(0, gameState.playerCount).filter(p => gameState.bloodwells[p].length > 0);
            if (remainingPlayers.length === 1) {
                showVictoryMessage(remainingPlayers[0]);
            }
        }

        function restartGame() {
            document.getElementById('victory-message').style.display = 'none';
            document.getElementById('game-screen').style.display = 'none';
            document.getElementById('setup-screen').style.display = 'block';
            gameState = {
                setupStep: 1,
                currentPlayer: 0,
                turn: 1,
                ap: apPerTurn[1],
                playerCount: 0,
                guardians: {},
                bloodwells: {},
                obstacles: [],
                obstacleCount: 0,
                selectedGuardian: null,
                selectedAction: null,
                playerClasses: {},
                playerNames: {},
                silverSlugs: {},
                cursed: {},
                usedAbilities: {},
                layout: null,
                turnHistory: [],
                actionsThisTurn: []
            };
            renderSetupScreen();
        }

        window.onload = renderSetupScreen;
    </script>
</body>
</html>
