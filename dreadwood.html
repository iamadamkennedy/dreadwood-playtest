<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dreadwood Playtest</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Old+English+Text+MT&display=swap');
        body {
            font-family: 'Bebas Neue', sans-serif;
            background: url('https://images.unsplash.com/photo-1507521628349-dee6b57683e4?ixlib=rb-4.0.3&auto=format&fit=crop&w=1350&q=80') no-repeat center center fixed;
            background-size: cover;
            color: #fff;
            text-align: center;
            margin: 0;
            padding: 0;
            position: relative;
        }
        body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: -1;
        }
        h1 {
            font-family: 'Old English Text MT', serif;
            color: #ff0000;
            text-shadow: 2px 2px 4px #000;
            margin: 20px 0;
        }
        #setup-screen, #game-screen {
            margin: 20px auto;
            max-width: 90%;
        }
        #setup-screen {
            display: block;
            background: url('https://www.transparenttextures.com/patterns/paper-fibers.png');
            padding: 20px;
            border: 2px solid #8b0000;
            border-radius: 10px;
        }
        #game-screen {
            display: none;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: flex-start;
        }
        #game-info {
            background: url('https://www.transparenttextures.com/patterns/paper-fibers.png');
            padding: 10px;
            border: 2px solid #8b0000;
            border-radius: 5px;
            margin: 10px 0;
            font-family: 'Old English Text MT', serif;
            width: 100%;
            box-sizing: border-box;
        }
        #game-info span {
            font-family: 'Bebas Neue', sans-serif;
            color: #ff0000;
        }
        #grid-container {
            position: relative;
            margin: 10px;
        }
        #grid {
            display: grid;
            gap: 1px;
            background: url('https://www.transparenttextures.com/patterns/cracked-soil.png');
            padding: 5px;
            border: 2px solid #333;
        }
        .cell {
            background: rgba(85, 85, 85, 0.8);
            border: 1px solid #000;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            cursor: pointer;
            position: relative;
        }
        .cell::before {
            content: attr(data-coord);
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: #fff;
        }
        .cell::after {
            content: attr(data-row);
            position: absolute;
            left: -20px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 10px;
            color: #fff;
        }
        .guardian { font-size: 16px; }
        .guardian.sheriff { background: #fff; }
        .guardian.vigilante { background: #00f; }
        .guardian.outlaw { background: #f00; }
        .guardian.bounty-hunter { background: #0f0; }
        .bloodwell { background: #000; }
        .bloodwell::before { content: '🩸'; font-size: 16px; }
        .tombstone::before { content: '🪦'; }
        .carcass::before { content: '💀'; }
        .grave-dust::before { content: '💩'; }
        .dynamite::before { content: '💥'; }
        .cursed { border: 2px solid #800080; }
        .shared .obstacle {
            position: absolute;
            bottom: 5px;
            right: 5px;
            font-size: 12px;
        }
        .selected { box-shadow: 0 0 5px 2px #ffff00; }
        .arrow {
            position: absolute;
            background: rgba(255, 255, 255, 0.5);
            font-size: 16px;
            cursor: pointer;
        }
        .arrow:hover {
            background: rgba(255, 255, 255, 0.8);
        }
        #actions {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 10px;
        }
        .action-icon {
            margin: 5px;
            padding: 5px;
            background: url('https://www.transparenttextures.com/patterns/wood-pattern.png');
            border: 2px solid #8b0000;
            border-radius: 5px;
            font-size: 30px;
            cursor: pointer;
        }
        .action-icon:hover {
            box-shadow: 0 0 5px 2px #ff0000;
        }
        #class-info {
            background: url('https://www.transparenttextures.com/patterns/paper-fibers.png');
            padding: 10px;
            border: 2px solid #8b0000;
            border-radius: 5px;
            margin: 10px;
            text-align: left;
            max-width: 300px;
        }
        #class-info h3 {
            font-family: 'Old English Text MT', serif;
            margin: 0;
        }
        #class-info p, #class-info ul {
            font-family: 'Bebas Neue', sans-serif;
            color: #fff;
            font-size: 14px;
            margin: 5px 0;
        }
        #class-info ul {
            list-style: none;
            padding: 0;
        }
        #class-info li {
            margin: 5px 0;
        }
        #class-info strong {
            color: #ff0000;
        }
        #class-info .used {
            color: #888;
            cursor: default;
        }
        #class-info .active-ability {
            cursor: pointer;
        }
        #class-info .active-ability:hover {
            text-decoration: underline;
        }
        #controls {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            margin: 10px 0;
            width: 100%;
        }
        button {
            margin: 5px;
            padding: 5px 10px;
            background: url('https://www.transparenttextures.com/patterns/wood-pattern.png');
            color: #ff0000;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Bebas Neue', sans-serif;
            text-transform: uppercase;
        }
        button:hover {
            box-shadow: 0 0 5px 2px #ff0000;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        select, input[type="checkbox"], input[type="text"] {
            padding: 5px;
            margin: 5px;
            background: url('https://www.transparenttextures.com/patterns/paper-fibers.png');
            color: #ff0000;
            border: 1px solid #8b0000;
            border-radius: 5px;
            font-family: 'Bebas Neue', sans-serif;
        }
        .class-selection {
            margin: 10px 0;
        }
        .class-selection button {
            margin: 2px;
            padding: 5px;
            font-size: 14px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .class-selection button.sheriff { background: #fff; color: #000; }
        .class-selection button.vigilante { background: #00f; color: #fff; }
        .class-selection button.outlaw { background: #f00; color: #fff; }
        .class-selection button.bounty-hunter { background: #0f0; color: #fff; }
        .class-selection button.selected {
            outline: 2px solid #8b0000;
            box-shadow: 0 0 5px 2px #8b0000;
        }
        .class-info {
            background: url('https://www.transparenttextures.com/patterns/paper-fibers.png');
            padding: 10px;
            border: 2px solid #8b0000;
            border-radius: 5px;
            margin: 10px 0;
            text-align: left;
        }
        .class-name {
            font-family: 'Old English Text MT', serif;
            margin: 0;
        }
        .class-name.sheriff { color: #fff; }
        .class-name.vigilante { color: #00f; }
        .class-name.outlaw { color: #f00; }
        .class-name.bounty-hunter { color: #0f0; }
        .class-description {
            font-family: 'Bebas Neue', sans-serif;
            color: #fff;
            font-size: 14px;
            margin: 5px 0;
        }
        .class-abilities {
            list-style: none;
            padding: 0;
            color: #fff;
            font-family: 'Bebas Neue', sans-serif;
            font-size: 14px;
        }
        .class-abilities li {
            margin: 5px 0;
        }
        .class-abilities strong {
            color: #ff0000;
        }
        #elimination-message, #victory-message {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: url('https://www.transparenttextures.com/patterns/paper-fibers.png');
            padding: 20px;
            border: 2px solid #8b0000;
            border-radius: 10px;
            font-family: 'Old English Text MT', serif;
            color: #ff0000;
            text-shadow: 2px 2px 4px #000;
            font-size: 24px;
            z-index: 1000;
            text-align: center;
        }
        @media (max-width: 600px) {
            #grid {
                grid-template-columns: repeat(9, 40px);
            }
            .cell {
                width: 40px;
                height: 40px;
                font-size: 14px;
            }
            .guardian { font-size: 14px; }
            .bloodwell::before { font-size: 14px; }
            .shared .obstacle { font-size: 10px; }
            .arrow { font-size: 14px; }
            .action-icon { font-size: 24px; }
            #class-info {
                max-width: 100%;
                margin: 10px 0;
            }
            h1 { font-size: 20px; }
            #game-info, .class-description, .class-abilities {
                font-size: 12px;
            }
            button { font-size: 14px; width: 100%; }
        }
        @media (min-width: 600px) and (max-width: 1200px) {
            #grid {
                grid-template-columns: repeat(9, 45px);
            }
            .cell {
                width: 45px;
                height: 45px;
                font-size: 15px;
            }
            .guardian { font-size: 15px; }
            .bloodwell::before { font-size: 15px; }
            .shared .obstacle { font-size: 11px; }
            .arrow { font-size: 15px; }
            .action-icon { font-size: 30px; }
        }
        @media (min-width: 1200px) {
            #grid {
                grid-template-columns: repeat(9, 50px);
            }
            .cell {
                width: 50px;
                height: 50px;
                font-size: 16px;
            }
            .guardian { font-size: 16px; }
            .bloodwell::before { font-size: 16px; }
            .shared .obstacle { font-size: 12px; }
            .arrow { font-size: 16px; }
            .action-icon { font-size: 40px; }
            h1 { font-size: 24px; }
            #game-info, .class-description, .class-abilities {
                font-size: 14px;
            }
            button { font-size: 16px; }
        }
    </style>
</head>
<body>
    <div id="setup-screen">
        <h1>Dreadwood Setup</h1>
        <div>
            <label for="player-count">Number of Players:</label>
            <select id="player-count">
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
            </select>
        </div>
        <div id="class-selections"></div>
        <div>
            <label for="layout-select">Choose Layout:</label>
            <select id="layout-select">
                <!-- Options will be populated dynamically -->
            </select>
        </div>
        <div>
            <label for="dread-fates">Use Dread Fates:</label>
            <input type="checkbox" id="dread-fates">
        </div>
        <button onclick="startGame()">Start Game</button>
    </div>

    <div id="game-screen">
        <div id="actions">
            <div class="action-icon" onclick="selectAction('shoot')">🔫</div>
            <div class="action-icon" onclick="selectThrow('Tombstone')">🪦</div>
            <div class="action-icon" onclick="selectThrow('Carcass')">💀</div>
            <div class="action-icon" onclick="selectThrow('Grave Dust')">💩</div>
            <div class="action-icon" onclick="selectThrow('Dynamite')">💥</div>
            <div class="action-icon special-action" id="shoot-grave-dust" style="display: none;" onclick="selectAction('shootGraveDust')">🔫⬇️</div>
            <div class="action-icon special-action" id="bite-fuse" style="display: none;" onclick="selectAction('bite')">🍽️💥🤢</div>
            <div class="action-icon" onclick="selectAction('ability')">⚡</div>
        </div>
        <div id="grid-container">
            <div id="grid"></div>
        </div>
        <div id="class-info"></div>
        <div id="game-info">
            <p>Current Player: <span id="current-player">P1</span> | AP Left: <span id="ap-left">4</span> | Turn: <span id="turn">1</span></p>
            <p>Obstacles: <span id="obstacle-count">0</span>/12 | Dread Fates: <span id="dread-fates-status">Off</span></p>
        </div>
        <div id="controls">
            <button id="undo-button" onclick="undoTurn()" disabled>Undo</button>
            <button onclick="endTurn()">End Turn</button>
        </div>
    </div>
    <div id="elimination-message"></div>
    <div id="victory-message"></div>

    <script>
        const GRID_SIZE = 9;
        const players = ['P1', 'P2', 'P3', 'P4'];
        const classes = ['Sheriff', 'Vigilante', 'Outlaw', 'Bounty Hunter'];
        const colors = { 'P1': 'white', 'P2': 'blue', 'P3': 'red', 'P4': 'green' };
        const apPerTurn = { 1: 4, 2: 5, 3: 6, 4: 8 };
        let gameState = {
            currentPlayer: 0,
            turn: 1,
            ap: apPerTurn[1],
            playerCount: 2,
            guardians: {},
            bloodwells: {},
            obstacles: [],
            obstacleCount: 0,
            selectedGuardian: null,
            selectedAction: null,
            dreadFates: false,
            playerClasses: {},
            playerFates: {},
            cursed: {},
            usedAbilities: {},
            layout: null,
            playerNames: {},
            turnHistory: [],
            actionsThisTurn: []
        };

        const classInfo = {
            'Sheriff': {
                description: 'A vampire lawman enforcing order in a chaotic frontier.',
                abilities: [
                    { name: 'Under My Protection', type: 'passive', description: 'Bloodwells adjacent to a Sheriff’s Guardian are immune to regular shots.' },
                    { name: 'Swift Justice', type: 'passive', description: 'At the end of the turn, after spending AP, choose one Guardian to move 1 square in its facing direction (0 AP).' },
                    { name: 'Order Restored', type: 'active', cost: 3, description: 'Revive a Guardian, place adjacent to any Guardian or Bloodwell, once per game.' }
                ]
            },
            'Vigilante': {
                description: 'A vampire avenger seeking justice, using teamwork to punish wrongdoers.',
                abilities: [
                    { name: 'Side by Side', type: 'passive', description: 'Split AP between two Guardians each turn.' },
                    { name: 'Blood Brothers', type: 'passive', description: 'If both Guardians are within a 3x3 grid at the start of the turn, gain +1 AP for the turn, provided both use at least 1 AP.' },
                    { name: 'Vengeance is Mine', type: 'active', cost: 0, description: 'Gain 7 AP next turn after a Bloodwell/Guardian is shot, split via Side by Side, once per game.' }
                ]
            },
            'Outlaw': {
                description: 'A vampire bandit thriving on chaos, disrupting and escaping with speed.',
                abilities: [
                    { name: 'Daring Escape', type: 'passive', description: 'After shooting a Bloodwell (3 AP), turn to any direction and move up to 2 squares in that direction (1 AP), once per turn.' },
                    { name: 'Hand Cannon', type: 'active', cost: 5, description: 'Shoot all in one direction up to 5 spaces, ignores obstacles except Under My Protection, once per game.' },
                    { name: 'Rampage', type: 'active', cost: 2, description: 'Shoot left and right of facing direction, once per game.' }
                ]
            },
            'Bounty Hunter': {
                description: 'A vampire mercenary hunting for profit, using precision to eliminate targets.',
                abilities: [
                    { name: 'Sharpshooter', type: 'passive', description: 'Shots ignore Tombstones in their line of sight.' },
                    { name: 'Marked Man', type: 'passive', description: 'Shots on enemy Guardians curse them (move 1, shoot own square only, no throw, clear square to heal), instead of eliminating.' },
                    { name: 'Contract Payoff', type: 'active', cost: 3, description: 'Shoot a Bloodwell; if successful, gain +3 AP next turn (max 8 AP) in 2P, +5 AP (max 10 AP) in 3P/4P, once per game.' }
                ]
            }
        };

        const layouts = {
            '2P': [
                {
                    guardians: {
                        'P1': [{ pos: 'A2', facing: 'S' }, { pos: 'C4', facing: 'S' }],
                        'P2': [{ pos: 'A7', facing: 'N' }, { pos: 'C9', facing: 'N' }]
                    },
                    bloodwells: {
                        'P1': ['B1', 'D3', 'F2'],
                        'P2': ['B6', 'D8', 'F7']
                    },
                    obstacles: [
                        { type: 'Tombstone', pos: 'E5' },
                        { type: 'Carcass', pos: 'D5' },
                        { type: 'Grave Dust', pos: 'F5' },
                        { type: 'Dynamite', pos: 'G5' }
                    ]
                },
                // 25 more layouts generated off-screen
            ],
            '3P': [
                {
                    guardians: {
                        'P1': [{ pos: 'A2', facing: 'S' }, { pos: 'C4', facing: 'S' }],
                        'P2': [{ pos: 'F2', facing: 'S' }, { pos: 'H4', facing: 'S' }],
                        'P3': [{ pos: 'D8', facing: 'N' }, { pos: 'F9', facing: 'N' }]
                    },
                    bloodwells: {
                        'P1': ['B1', 'D3', 'A5'],
                        'P2': ['G1', 'I3', 'G5'],
                        'P3': ['C7', 'E6', 'G8']
                    },
                    obstacles: [
                        { type: 'Tombstone', pos: 'E5' },
                        { type: 'Carcass', pos: 'D5' },
                        { type: 'Grave Dust', pos: 'F5' },
                        { type: 'Dynamite', pos: 'G5' },
                        { type: 'Tombstone', pos: 'H5' }
                    ]
                },
                // 25 more layouts generated off-screen
            ],
            '4P': [
                {
                    guardians: {
                        'P1': [{ pos: 'A2', facing: 'S' }, { pos: 'C4', facing: 'S' }],
                        'P2': [{ pos: 'F2', facing: 'S' }, { pos: 'H4', facing: 'S' }],
                        'P3': [{ pos: 'A7', facing: 'N' }, { pos: 'C9', facing: 'N' }],
                        'P4': [{ pos: 'F7', facing: 'N' }, { pos: 'H9', facing: 'N' }]
                    },
                    bloodwells: {
                        'P1': ['B1', 'D3', 'A3'],
                        'P2': ['G1', 'I3', 'F3'],
                        'P3': ['B6', 'D8', 'A8'],
                        'P4': ['G6', 'I8', 'F8']
                    },
                    obstacles: [
                        { type: 'Tombstone', pos: 'E5' },
                        { type: 'Carcass', pos: 'D5' },
                        { type: 'Grave Dust', pos: 'F5' },
                        { type: 'Dynamite', pos: 'G5' },
                        { type: 'Tombstone', pos: 'E4' },
                        { type: 'Carcass', pos: 'E6' }
                    ]
                },
                // 25 more layouts generated off-screen
            ]
        };

        const dreadFates = [
            { name: 'Bloodlust', effect: '+1 AP on well shot, once/turn (max 6)' },
            { name: 'Grave Whisper', effect: 'Throw Grave Dust 0 AP, once/turn' },
            { name: 'Dust Runner', effect: 'Move through Carcass without stopping' },
            { name: 'Iron Will', effect: 'Immune to curses' },
            { name: 'Stake Driver', effect: 'Shoot obstacle 2 AP (normally 3)' },
            { name: 'Night Stalker', effect: '+1 space to first move/turn (max 5)' },
            { name: 'Wanted Poster', effect: 'Start with 2 silver slugs' },
            { name: 'Crypt Keeper', effect: 'First Tombstone immovable' },
            { name: 'Quick Draw', effect: 'First shot/turn 2 AP (normally 3)' },
            { name: 'Vampire’s Gambit', effect: 'Blood Ritual 2 AP (normally 3)' },
            { name: 'Shadow Veil', effect: 'Silver slugs on you cost 4 AP (normally 3)' },
            { name: 'Dread’s Edge', effect: '+1 AP on Guardian elimination, once/game (max 6)' }
        ];

        function initSetup() {
            const playerCountSelect = document.getElementById('player-count');
            playerCountSelect.onchange = updateClassSelections;
            updateClassSelections();
            populateLayoutSelect();
        }

        function updateClassSelections() {
            const playerCount = parseInt(document.getElementById('player-count').value);
            const classSelectionsDiv = document.getElementById('class-selections');
            classSelectionsDiv.innerHTML = '';

            for (let i = 1; i <= playerCount; i++) {
                const playerDiv = document.createElement('div');
                playerDiv.className = 'class-selection';
                playerDiv.innerHTML = `
                    <label>Player ${i} Class:</label>
                    <button class="sheriff" onclick="selectClass('P${i}', 'Sheriff')">⭐ Sheriff</button>
                    <button class="vigilante" onclick="selectClass('P${i}', 'Vigilante')">⚖️ Vigilante</button>
                    <button class="outlaw" onclick="selectClass('P${i}', 'Outlaw')">💣 Outlaw</button>
                    <button class="bounty-hunter" onclick="selectClass('P${i}', 'Bounty Hunter')">💰 Bounty Hunter</button>
                `;
                const classInfoDiv = document.createElement('div');
                classInfoDiv.className = 'class-info';
                classInfoDiv.id = `class-info-P${i}`;
                classInfoDiv.innerHTML = `<p>Select a class to view details.</p>`;
                playerDiv.appendChild(classInfoDiv);

                const nameDiv = document.createElement('div');
                nameDiv.innerHTML = `
                    <label for="name-P${i}">Player ${i} Name:</label>
                    <input type="text" id="name-P${i}" placeholder="P${i}" maxlength="20">
                `;
                playerDiv.appendChild(nameDiv);

                classSelectionsDiv.appendChild(playerDiv);
            }
        }

        function populateLayoutSelect() {
            const layoutSelect = document.getElementById('layout-select');
            layoutSelect.innerHTML = '';
            for (let i = 1; i <= 26; i++) {
                const option = document.createElement('option');
                option.value = i - 1;
                option.textContent = `Layout ${i}`;
                layoutSelect.appendChild(option);
            }
        }

        function selectClass(player, className) {
            gameState.playerClasses[player] = className;
            const buttons = document.querySelectorAll(`#class-selections button[onclick*="selectClass('${player}'"]`);
            buttons.forEach(button => {
                if (button.textContent.includes(className)) {
                    button.classList.add('selected');
                } else {
                    button.classList.remove('selected');
                }
            });

            const classInfoDiv = document.getElementById(`class-info-${player}`);
            const info = classInfo[player];
            classInfoDiv.innerHTML = `
                <h3 class="class-name ${className.toLowerCase()}">${className}</h3>
                <p class="class-description">${info.description}</p>
                <ul class="class-abilities">
                    ${info.abilities.map(ability => `
                        <li><strong>${ability.name}${ability.cost ? ` (${ability.cost} AP)` : ''}:</strong> ${ability.description}</li>
                    `).join('')}
                </ul>
            `;
        }

        function startGame() {
            gameState.playerCount = parseInt(document.getElementById('player-count').value);
            if (gameState.playerCount < 2 || gameState.playerCount > 4) {
                alert("Invalid player count. Defaulting to 2 players.");
                gameState.playerCount = 2;
            }

            for (let i = 1; i <= gameState.playerCount; i++) {
                if (!gameState.playerClasses[`P${i}`]) {
                    alert(`Please select a class for Player ${i}!`);
                    return;
                }
                const nameInput = document.getElementById(`name-P${i}`).value.trim();
                gameState.playerNames[`P${i}`] = nameInput || `P${i}`;
            }

            const layoutIndex = parseInt(document.getElementById('layout-select').value);
            const layout = layouts[`${gameState.playerCount}P`][layoutIndex];
            gameState.layout = layout;
            gameState.guardians = {};
            gameState.bloodwells = {};
            gameState.obstacles = layout.obstacles;
            gameState.obstacleCount = layout.obstacles.length;

            for (let i = 1; i <= gameState.playerCount; i++) {
                const player = `P${i}`;
                gameState.guardians[player] = layout.guardians[player].map((g, idx) => ({
                    id: `${player}G${idx + 1}`,
                    pos: g.pos,
                    facing: g.facing,
                    alive: true
                }));
                gameState.bloodwells[player] = layout.bloodwells[player];
                gameState.cursed[`${player}G1`] = false;
                gameState.cursed[`${player}G2`] = false;
                gameState.usedAbilities[player] = {};
            }

            if (gameState.playerCount === 4) {
                const p4Well = prompt(`${gameState.playerNames['P4']}: Place free Tombstone adjacent to a Bloodwell (e.g., I7 next to I8):`, "I7");
                gameState.obstacles.push({ type: 'Tombstone', pos: p4Well });
                gameState.obstacleCount++;
            }

            gameState.dreadFates = document.getElementById('dread-fates').checked;
            if (gameState.dreadFates) {
                const shuffledFates = dreadFates.sort(() => Math.random() - 0.5);
                for (let i = 1; i <= gameState.playerCount; i++) {
                    gameState.playerFates[`P${i}`] = shuffledFates[i - 1];
                    alert(`${gameState.playerNames[`P${i}`]} drew Dread Fate: ${gameState.playerFates[`P${i}`].name} - ${gameState.playerFates[`P${i}`].effect}`);
                }
            }

            document.getElementById('setup-screen').style.display = 'none';
            document.getElementById('game-screen').style.display = 'flex';
            document.getElementById('dread-fates-status').textContent = gameState.dreadFates ? 'On' : 'Off';
            renderGrid();
            updateGameInfo();
            updateClassInfo();
        }

        function renderGrid() {
            const grid = document.getElementById('grid');
            grid.innerHTML = '';
            for (let row = 1; row <= GRID_SIZE; row++) {
                for (let col = 1; col <= GRID_SIZE; col++) {
                    const pos = String.fromCharCode(64 + col) + row;
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.id = pos;
                    cell.setAttribute('data-coord', String.fromCharCode(64 + col));
                    cell.setAttribute('data-row', row);
                    cell.onclick = () => selectCell(pos);

                    let content = '';
                    let hasGuardian = false;
                    let hasObstacle = false;
                    let obstacleType = '';

                    for (let player in gameState.guardians) {
                        const guardian = gameState.guardians[player].find(g => g.pos === pos && g.alive);
                        if (guardian) {
                            content = '♟️';
                            cell.classList.add('guardian');
                            cell.classList.add(gameState.playerClasses[player].toLowerCase());
                            if (gameState.cursed[guardian.id]) cell.classList.add('cursed');
                            hasGuardian = true;
                            break;
                        }
                    }

                    if (!hasGuardian) {
                        for (let player in gameState.bloodwells) {
                            if (gameState.bloodwells[player].includes(pos)) {
                                content = '';
                                cell.classList.add('bloodwell');
                                cell.classList.add(gameState.playerClasses[player].toLowerCase());
                                break;
                            }
                        }
                    }

                    const obstacle = gameState.obstacles.find(o => o.pos === pos);
                    if (obstacle) {
                        hasObstacle = true;
                        obstacleType = obstacle.type.toLowerCase().replace(' ', '-');
                        if (!hasGuardian) {
                            content = '';
                            cell.classList.add(obstacleType);
                        }
                    }

                    if (hasGuardian && hasObstacle) {
                        cell.classList.add('shared');
                        const obstacleSpan = document.createElement('span');
                        obstacleSpan.className = `obstacle ${obstacleType}`;
                        cell.appendChild(obstacleSpan);
                    }

                    cell.innerHTML += content;
                    grid.appendChild(cell);
                }
            }

            if (gameState.selectedGuardian) {
                const pos = gameState.selectedGuardian.pos;
                const cell = document.getElementById(pos);
                cell.classList.add('selected');

                const [col, row] = [pos.charCodeAt(0) - 64, parseInt(pos[1])];
                const directions = [
                    { dir: 'N', pos: `${String.fromCharCode(64 + col)}${row - 1}`, emoji: '⬆️' },
                    { dir: 'S', pos: `${String.fromCharCode(64 + col)}${row + 1}`, emoji: '⬇️' },
                    { dir: 'E', pos: `${String.fromCharCode(64 + col + 1)}${row}`, emoji: '➡️' },
                    { dir: 'W', pos: `${String.fromCharCode(64 + col - 1)}${row}`, emoji: '⬅️' }
                ];

                directions.forEach(({ dir, pos, emoji }) => {
                    if (row > 1 && dir === 'N' || row < GRID_SIZE && dir === 'S' || col > 1 && dir === 'W' || col < GRID_SIZE && dir === 'E') {
                        const arrowCell = document.getElementById(pos);
                        if (arrowCell) {
                            const arrow = document.createElement('div');
                            arrow.className = 'arrow';
                            arrow.innerHTML = emoji;
                            arrow.onclick = () => handleArrowClick(dir);
                            arrowCell.appendChild(arrow);
                        }
                    }
                });

                const currentPos = gameState.selectedGuardian.pos;
                const obstacle = gameState.obstacles.find(o => o.pos === currentPos);
                const shootGraveDust = document.getElementById('shoot-grave-dust');
                const biteFuse = document.getElementById('bite-fuse');
                shootGraveDust.style.display = obstacle && obstacle.type === 'Grave Dust' ? 'block' : 'none';
                biteFuse.style.display = obstacle && obstacle.type === 'Dynamite' ? 'block' : 'none';
            }
        }

        function selectCell(pos) {
            const player = players[gameState.currentPlayer];
            const guardian = gameState.guardians[player].find(g => g.pos === pos && g.alive);
            if (guardian) {
                gameState.selectedGuardian = guardian;
                gameState.selectedAction = null;
                renderGrid();
                updateClassInfo();
            } else if (gameState.selectedGuardian && gameState.selectedAction) {
                executeAction(pos);
            }
        }

        function selectAction(action) {
            gameState.selectedAction = action;
            renderGrid();
        }

        function selectThrow(obstacle) {
            gameState.selectedAction = 'throw';
            gameState.selectedObstacle = obstacle;
            renderGrid();
        }

        function handleArrowClick(direction) {
            if (!gameState.selectedGuardian) return;
            const guardian = gameState.selectedGuardian;
            if (gameState.cursed[guardian.id]) {
                alert("This Guardian is cursed and cannot move or turn!");
                return;
            }

            if (guardian.facing === direction) {
                gameState.selectedAction = 'move';
            } else {
                gameState.selectedAction = 'turn';
                gameState.selectedDirection = direction;
            }
            const [col, row] = [guardian.pos.charCodeAt(0) - 64, parseInt(guardian.pos[1])];
            let targetPos;
            if (direction === 'N') targetPos = `${String.fromCharCode(64 + col)}${row - 1}`;
            if (direction === 'S') targetPos = `${String.fromCharCode(64 + col)}${row + 1}`;
            if (direction === 'E') targetPos = `${String.fromCharCode(64 + col + 1)}${row}`;
            if (direction === 'W') targetPos = `${String.fromCharCode(64 + col - 1)}${row}`;
            executeAction(targetPos);
        }

        function executeAction(targetPos) {
            const player = players[gameState.currentPlayer];
            const guardian = gameState.selectedGuardian;
            const action = gameState.selectedAction;
            let apCost = 0;

            const currentState = JSON.parse(JSON.stringify({
                guardians: gameState.guardians,
                bloodwells: gameState.bloodwells,
                obstacles: gameState.obstacles,
                obstacleCount: gameState.obstacleCount,
                cursed: gameState.cursed,
                usedAbilities: gameState.usedAbilities,
                ap: gameState.ap
            }));
            gameState.actionsThisTurn.push(currentState);

            if (action === 'move') {
                apCost = 1;
                if (gameState.ap >= apCost) {
                    const newPos = canMove(guardian, targetPos);
                    if (newPos) {
                        guardian.pos = targetPos;
                        gameState.ap -= apCost;
                        alert(`${gameState.playerNames[player]}'s ${guardian.id} moved to ${targetPos}`);
                    }
                }
            } else if (action === 'turn') {
                apCost = 1;
                if (gameState.ap >= apCost) {
                    guardian.facing = gameState.selectedDirection;
                    gameState.ap -= apCost;
                    alert(`${gameState.playerNames[player]}'s ${guardian.id} turned to face ${guardian.facing}`);
                }
            } else if (action === 'shoot') {
                apCost = 3;
                if (gameState.ap >= apCost) {
                    const target = canShoot(guardian, targetPos);
                    if (target) {
                        handleShot(guardian, targetPos);
                        gameState.ap -= apCost;
                    }
                }
            } else if (action === 'throw') {
                const obstacleType = gameState.selectedObstacle;
                apCost = obstacleType === 'Dynamite' ? 2 : 1;
                if (gameState.ap >= apCost && gameState.obstacleCount < 12) {
                    const canThrow = canThrowObstacle(guardian, targetPos, obstacleType);
                    if (canThrow) {
                        gameState.obstacles.push({ type: obstacleType, pos: targetPos });
                        gameState.obstacleCount++;
                        gameState.ap -= apCost;
                        alert(`${gameState.playerNames[player]}'s ${guardian.id} threw ${obstacleType} to ${targetPos}`);
                    }
                } else if (gameState.obstacleCount >= 12) {
                    alert("Obstacle limit (12) reached!");
                }
            } else if (action === 'shootGraveDust') {
                apCost = 3;
                if (gameState.ap >= apCost) {
                    const pos = guardian.pos;
                    const obstacle = gameState.obstacles.find(o => o.pos === pos && o.type === 'Grave Dust');
                    if (obstacle) {
                        gameState.obstacles = gameState.obstacles.filter(o => o !== obstacle);
                        gameState.obstacleCount--;
                        gameState.ap -= apCost;
                        alert(`${gameState.playerNames[player]}'s ${guardian.id} shot the Grave Dust at ${pos}`);
                    }
                }
            } else if (action === 'bite') {
                apCost = 1;
                if (gameState.ap >= apCost) {
                    const pos = guardian.pos;
                    const obstacle = gameState.obstacles.find(o => o.pos === pos && o.type === 'Dynamite');
                    if (obstacle) {
                        gameState.obstacles = gameState.obstacles.filter(o => o !== obstacle);
                        gameState.obstacleCount--;
                        gameState.cursed[guardian.id] = true;
                        gameState.ap -= apCost;
                        alert(`${gameState.playerNames[player]}'s ${guardian.id} bit the fuse at ${pos} and is now cursed!`);
                    }
                }
            } else if (action === 'ability') {
                const ability = gameState.playerClasses[player];
                if (ability === 'Sheriff') {
                    apCost = 3;
                    if (gameState.ap >= apCost) {
                        const deadGuardian = gameState.guardians[player].find(g => !g.alive);
                        if (deadGuardian) {
                            deadGuardian.alive = true;
                            deadGuardian.pos = targetPos;
                            gameState.ap -= apCost;
                            gameState.usedAbilities[player]['Order Restored'] = true;
                            alert(`${gameState.playerNames[player]} used Order Restored: Revived ${deadGuardian.id} at ${targetPos}`);
                        } else {
                            alert("No dead Guardians to revive!");
                            gameState.actionsThisTurn.pop();
                            return;
                        }
                    }
                } else if (ability === 'Vigilante') {
                    alert("Vengeance is Mine triggers on opponent shot!");
                    gameState.actionsThisTurn.pop();
                    return;
                } else if (ability === 'Outlaw') {
                    const subAction = targetPos === 'Hand Cannon' ? 'Hand Cannon' : 'Rampage';
                    apCost = subAction === 'Hand Cannon' ? 5 : 2;
                    if (gameState.ap >= apCost) {
                        if (subAction === 'Hand Cannon') {
                            const direction = prompt("Choose direction for Hand Cannon (N, S, E, W):", guardian.facing);
                            if (['N', 'S', 'E', 'W'].includes(direction)) {
                                handleHandCannon(guardian, direction);
                            } else {
                                alert("Invalid direction!");
                                gameState.actionsThisTurn.pop();
                                return;
                            }
                        } else {
                            handleRampage(guardian);
                        }
                        gameState.ap -= apCost;
                        gameState.usedAbilities[player][subAction] = true;
                    }
                } else if (ability === 'Bounty Hunter') {
                    apCost = 3;
                    if (gameState.ap >= apCost) {
                        const target = canShoot(guardian, targetPos);
                        if (target && target.includes('B')) {
                            gameState.ap -= apCost;
                            gameState.usedAbilities[player]['Contract Payoff'] = true;
                            alert(`${gameState.playerNames[player]} used Contract Payoff: Shot ${target}, +${gameState.playerCount === 2 ? 3 : 5} AP next turn`);
                            // AP boost logic handled in endTurn
                        } else {
                            alert("Contract Payoff requires shooting a Bloodwell!");
                            gameState.actionsThisTurn.pop();
                            return;
                        }
                    }
                }
            }

            gameState.selectedGuardian = null;
            gameState.selectedAction = null;
            renderGrid();
            updateGameInfo();
            updateClassInfo();
            checkGameState();
            document.getElementById('undo-button').disabled = gameState.actionsThisTurn.length === 0;
        }

        function canMove(guardian, targetPos) {
            const [targetCol, targetRow] = [targetPos.charCodeAt(0) - 64, parseInt(targetPos[1])];
            const [currentCol, currentRow] = [guardian.pos.charCodeAt(0) - 64, parseInt(guardian.pos[1])];
            const direction = guardian.facing;
            if (direction === 'N' && targetRow < currentRow && targetCol === currentCol) return true;
            if (direction === 'S' && targetRow > currentRow && targetCol === currentCol) return true;
            if (direction === 'E' && targetCol > currentCol && targetRow === currentRow) return true;
            if (direction === 'W' && targetCol < currentCol && targetRow === currentRow) return true;
            alert("Invalid move direction!");
            return false;
        }

        function canShoot(guardian, targetPos) {
            const [targetCol, targetRow] = [targetPos.charCodeAt(0) - 64, parseInt(targetPos[1])];
            const [currentCol, currentRow] = [guardian.pos.charCodeAt(0) - 64, parseInt(guardian.pos[1])];
            const direction = guardian.facing;
            let path = [];
            if (direction === 'N' && targetCol === currentCol && targetRow < currentRow) {
                for (let r = currentRow - 1; r >= targetRow; r--) path.push(`${String.fromCharCode(64 + currentCol)}${r}`);
            } else if (direction === 'S' && targetCol === currentCol && targetRow > currentRow) {
                for (let r = currentRow + 1; r <= targetRow; r++) path.push(`${String.fromCharCode(64 + currentCol)}${r}`);
            } else if (direction === 'E' && targetRow === currentRow && targetCol > currentCol) {
                for (let c = currentCol + 1; c <= targetCol; c++) path.push(`${String.fromCharCode(64 + c)}${currentRow}`);
            } else if (direction === 'W' && targetRow === currentRow && targetCol < currentCol) {
                for (let c = currentCol - 1; c >= targetCol; c++) path.push(`${String.fromCharCode(64 + c)}${currentRow}`);
            } else {
                alert("Invalid shot direction!");
                return null;
            }

            for (let pos of path.slice(0, -1)) {
                const obstacle = gameState.obstacles.find(o => o.pos === pos);
                if (obstacle) {
                    if (gameState.playerClasses[players[gameState.currentPlayer]] === 'Bounty Hunter' && obstacle.type === 'Tombstone') {
                        continue;
                    }
                    if (obstacle.type !== 'Grave Dust') {
                        alert("Shot blocked by obstacle!");
                        return null;
                    }
                }
            }

            for (let player in gameState.guardians) {
                const targetGuardian = gameState.guardians[player].find(g => g.pos === path[path.length - 1] && g.alive);
                if (targetGuardian && gameState.playerClasses[player] === 'Sheriff') {
                    for (let bloodwell of gameState.bloodwells[player]) {
                        const [bCol, bRow] = [bloodwell.charCodeAt(0) - 64, parseInt(bloodwell[1])];
                        if (Math.abs(bCol - targetCol) <= 1 && Math.abs(bRow - targetRow) <= 1) {
                            alert("Shot blocked by Under My Protection!");
                            return null;
                        }
                    }
                }
            }

            return path[path.length - 1];
        }

        function handleShot(guardian, targetPos) {
            const player = players[gameState.currentPlayer];
            const target = gameState.bloodwells[player].includes(targetPos) ? `${player}B` : null;
            if (target) {
                alert("Cannot shoot your own Bloodwell!");
                gameState.actionsThisTurn.pop();
                return;
            }

            for (let p in gameState.bloodwells) {
                if (p !== player && gameState.bloodwells[p].includes(targetPos)) {
                    gameState.bloodwells[p] = gameState.bloodwells[p].filter(pos => pos !== targetPos);
                    alert(`${gameState.playerNames[player]}'s ${guardian.id} shot ${gameState.playerNames[p]}'s Bloodwell at ${targetPos}`);
                    if (gameState.playerClasses[p] === 'Vigilante') {
                        alert(`${gameState.playerNames[p]} triggers Vengeance is Mine: +7 AP next turn`);
                        gameState.usedAbilities[p]['Vengeance is Mine'] = true;
                    }
                    if (gameState.playerClasses[player] === 'Outlaw') {
                        gameState.selectedAction = 'daringEscape';
                        renderGrid();
                    }
                    return;
                }
            }

            for (let p in gameState.guardians) {
                const targetGuardian = gameState.guardians[p].find(g => g.pos === targetPos && g.alive);
                if (targetGuardian) {
                    if (gameState.playerClasses[player] === 'Bounty Hunter') {
                        gameState.cursed[targetGuardian.id] = true;
                        alert(`${gameState.playerNames[player]}'s ${guardian.id} cursed ${gameState.playerNames[p]}'s ${targetGuardian.id} with Marked Man`);
                    } else {
                        alert("Shot ignored—use silver slug to eliminate!");
                    }
                    return;
                }
            }

            const obstacle = gameState.obstacles.find(o => o.pos === targetPos);
            if (obstacle) {
                if (obstacle.type === 'Dynamite') {
                    handleDynamiteExplosion(targetPos);
                } else {
                    gameState.obstacles = gameState.obstacles.filter(o => o.pos !== targetPos);
                    gameState.obstacleCount--;
                    alert(`${gameState.playerNames[player]}'s ${guardian.id} destroyed ${obstacle.type} at ${targetPos}`);
                }
            }
        }

        function handleDynamiteExplosion(pos) {
            const [col, row] = [pos.charCodeAt(0) - 64, parseInt(pos[1])];
            const radius = 3;
            const affected = [];
            for (let r = Math.max(1, row - 1); r <= Math.min(9, row + 1); r++) {
                for (let c = Math.max(1, col - 1); c <= Math.min(9, col + 1); c++) {
                    affected.push(`${String.fromCharCode(64 + c)}${r}`);
                }
            }

            gameState.obstacles = gameState.obstacles.filter(o => o.pos !== pos);
            gameState.obstacleCount--;
            alert(`Dynamite exploded at ${pos}, affecting ${affected.length} squares`);

            for (let p in gameState.bloodwells) {
                gameState.bloodwells[p] = gameState.bloodwells[p].filter(b => !affected.includes(b));
                if (gameState.bloodwells[p].length === 0) {
                    showEliminationMessage(p);
                }
            }
        }

        function canThrowObstacle(guardian, targetPos, type) {
            const [targetCol, targetRow] = [targetPos.charCodeAt(0) - 64, parseInt(targetPos[1])];
            const [currentCol, currentRow] = [guardian.pos.charCodeAt(0) - 64, parseInt(guardian.pos[1])];
            const direction = guardian.facing;
            let path = [];
            if (direction === 'N' && targetCol === currentCol && targetRow < currentRow) {
                for (let r = currentRow - 1; r >= targetRow; r--) path.push(`${String.fromCharCode(64 + currentCol)}${r}`);
            } else if (direction === 'S' && targetCol === currentCol && targetRow > currentRow) {
                for (let r = currentRow + 1; r <= targetRow; r++) path.push(`${String.fromCharCode(64 + currentCol)}${r}`);
            } else if (direction === 'E' && targetRow === currentRow && targetCol > currentCol) {
                for (let c = currentCol + 1; c <= targetCol; c++) path.push(`${String.fromCharCode(64 + c)}${currentRow}`);
            } else if (direction === 'W' && targetRow === currentRow && targetCol < currentCol) {
                for (let c = currentCol - 1; c >= targetCol; c++) path.push(`${String.fromCharCode(64 + c)}${currentRow}`);
            } else {
                alert("Invalid throw direction!");
                return false;
            }

            if (path.length > 3) {
                alert("Throw distance exceeds 3 squares!");
                return false;
            }

            for (let pos of path.slice(0, -1)) {
                if (gameState.obstacles.some(o => o.pos === pos) || Object.values(gameState.guardians).flat().some(g => g.pos === pos && g.alive)) {
                    alert("Throw path blocked!");
                    return false;
                }
            }

            const targetOccupied = Object.values(gameState.guardians).flat().some(g => g.pos === targetPos && g.alive) || gameState.obstacles.some(o => o.pos === targetPos);
            if (type === 'Grave Dust' && targetOccupied) {
                const targetGuardian = Object.values(gameState.guardians).flat().find(g => g.pos === targetPos && g.alive);
                if (targetGuardian) {
                    gameState.cursed[targetGuardian.id] = true;
                    alert(`${guardian.id} cursed ${targetGuardian.id} with Grave Dust`);
                    return false;
                }
            } else if (targetOccupied) {
                alert("Target square occupied!");
                return false;
            }

            return true;
        }

        function handleHandCannon(guardian, direction) {
            const [currentCol, currentRow] = [guardian.pos.charCodeAt(0) - 64, parseInt(guardian.pos[1])];
            let path = [];
            if (direction === 'N') {
                for (let r = currentRow - 1; r >= Math.max(1, currentRow - 5); r--) path.push(`${String.fromCharCode(64 + currentCol)}${r}`);
            } else if (direction === 'S') {
                for (let r = currentRow + 1; r <= Math.min(9, currentRow + 5); r++) path.push(`${String.fromCharCode(64 + currentCol)}${r}`);
            } else if (direction === 'E') {
                for (let c = currentCol + 1; c <= Math.min(9, currentCol + 5); c++) path.push(`${String.fromCharCode(64 + c)}${currentRow}`);
            } else if (direction === 'W') {
                for (let c = currentCol - 1; c >= Math.max(1, currentCol - 5); c--) path.push(`${String.fromCharCode(64 + c)}${currentRow}`);
            }

            for (let pos of path) {
                for (let p in gameState.bloodwells) {
                    if (gameState.bloodwells[p].includes(pos)) {
                        gameState.bloodwells[p] = gameState.bloodwells[p].filter(b => b !== pos);
                        alert(`${gameState.playerNames[players[gameState.currentPlayer]]}'s ${guardian.id} Hand Cannon hit ${gameState.playerNames[p]}'s Bloodwell at ${pos}`);
                    }
                }
                const obstacle = gameState.obstacles.find(o => o.pos === pos);
                if (obstacle) {
                    if (obstacle.type === 'Dynamite') {
                        handleDynamiteExplosion(pos);
                    } else {
                        gameState.obstacles = gameState.obstacles.filter(o => o.pos !== pos);
                        gameState.obstacleCount--;
                        alert(`${gameState.playerNames[players[gameState.currentPlayer]]}'s ${guardian.id} Hand Cannon destroyed ${obstacle.type} at ${pos}`);
                    }
                }
            }
        }

        function handleRampage(guardian) {
            const [col, row] = [guardian.pos.charCodeAt(0) - 64, parseInt(guardian.pos[1])];
            const direction = guardian.facing;
            let leftPos, rightPos;
            if (direction === 'N' || direction === 'S') {
                leftPos = col > 1 ? `${String.fromCharCode(64 + col - 1)}${row}` : null;
                rightPos = col < 9 ? `${String.fromCharCode(64 + col + 1)}${row}` : null;
            } else {
                leftPos = row > 1 ? `${String.fromCharCode(64 + col)}${row - 1}` : null;
                rightPos = row < 9 ? `${String.fromCharCode(64 + col)}${row + 1}` : null;
            }

            [leftPos, rightPos].forEach(pos => {
                if (pos) {
                    for (let p in gameState.bloodwells) {
                        if (gameState.bloodwells[p].includes(pos)) {
                            gameState.bloodwells[p] = gameState.bloodwells[p].filter(b => b !== pos);
                            alert(`${gameState.playerNames[players[gameState.currentPlayer]]}'s ${guardian.id} Rampage hit ${gameState.playerNames[p]}'s Bloodwell at ${pos}`);
                        }
                    }
                    const obstacle = gameState.obstacles.find(o => o.pos === pos);
                    if (obstacle) {
                        if (obstacle.type === 'Dynamite') {
                            handleDynamiteExplosion(pos);
                        } else {
                            gameState.obstacles = gameState.obstacles.filter(o => o.pos !== pos);
                            gameState.obstacleCount--;
                            alert(`${gameState.playerNames[players[gameState.currentPlayer]]}'s ${guardian.id} Rampage destroyed ${obstacle.type} at ${pos}`);
                        }
                    }
                }
            });
        }

        function endTurn() {
            const player = players[gameState.currentPlayer];
            if (gameState.playerClasses[player] === 'Sheriff') {
                const guardian = gameState.guardians[player].find(g => g.alive);
                if (guardian) {
                    const [col, row] = [guardian.pos.charCodeAt(0) - 64, parseInt(guardian.pos[1])];
                    let targetPos;
                    if (guardian.facing === 'N' && row > 1) targetPos = `${String.fromCharCode(64 + col)}${row - 1}`;
                    if (guardian.facing === 'S' && row < GRID_SIZE) targetPos = `${String.fromCharCode(64 + col)}${row + 1}`;
                    if (guardian.facing === 'E' && col < GRID_SIZE) targetPos = `${String.fromCharCode(64 + col + 1)}${row}`;
                    if (guardian.facing === 'W' && col > 1) targetPos = `${String.fromCharCode(64 + col - 1)}${row}`;
                    if (targetPos && canMove(guardian, targetPos)) {
                        guardian.pos = targetPos;
                        alert(`${gameState.playerNames[player]}'s ${guardian.id} moved to ${targetPos} via Swift Justice`);
                    }
                }
            }

            gameState.currentPlayer = (gameState.currentPlayer + 1) % gameState.playerCount;
            gameState.turn++;
            gameState.ap = apPerTurn[gameState.currentPlayer + 1];
            if (gameState.playerClasses[players[gameState.currentPlayer]] === 'Vigilante') {
                const g1 = gameState.guardians[players[gameState.currentPlayer]][0];
                const g2 = gameState.guardians[players[gameState.currentPlayer]][1];
                const [col1, row1] = [g1.pos.charCodeAt(0) - 64, parseInt(g1.pos[1])];
                const [col2, row2] = [g2.pos.charCodeAt(0) - 64, parseInt(g2.pos[1])];
                if (Math.abs(col1 - col2) <= 2 && Math.abs(row1 - row2) <= 2) {
                    gameState.ap += 1;
                    gameState.bloodBrothersActive = true;
                } else {
                    gameState.bloodBrothersActive = false;
                }
            }
            if (gameState.usedAbilities[players[gameState.currentPlayer]]?.['Contract Payoff']) {
                gameState.ap += gameState.playerCount === 2 ? 3 : 5;
                gameState.ap = Math.min(gameState.ap, gameState.playerCount === 2 ? 8 : 10);
                delete gameState.usedAbilities[players[gameState.currentPlayer]]['Contract Payoff'];
            }
            gameState.selectedGuardian = null;
            gameState.selectedAction = null;
            gameState.actionsThisTurn = [];
            gameState.turnHistory = [];
            document.getElementById('undo-button').disabled = true;
            alert(`Turn ended. Now ${gameState.playerNames[players[gameState.currentPlayer]]}'s turn.`);
            renderGrid();
            updateGameInfo();
            updateClassInfo();
        }

        function undoTurn() {
            if (gameState.actionsThisTurn.length === 0) return;
            const lastState = gameState.actionsThisTurn.pop();
            gameState.guardians = JSON.parse(JSON.stringify(lastState.guardians));
            gameState.bloodwells = JSON.parse(JSON.stringify(lastState.bloodwells));
            gameState.obstacles = JSON.parse(JSON.stringify(lastState.obstacles));
            gameState.obstacleCount = lastState.obstacleCount;
            gameState.cursed = JSON.parse(JSON.stringify(lastState.cursed));
            gameState.usedAbilities = JSON.parse(JSON.stringify(lastState.usedAbilities));
            gameState.ap = lastState.ap;
            gameState.selectedGuardian = null;
            gameState.selectedAction = null;
            renderGrid();
            updateGameInfo();
            updateClassInfo();
            document.getElementById('undo-button').disabled = gameState.actionsThisTurn.length === 0;
        }

        function updateGameInfo() {
            document.getElementById('current-player').textContent = gameState.playerNames[players[gameState.currentPlayer]];
            document.getElementById('ap-left').textContent = gameState.ap;
            document.getElementById('turn').textContent = gameState.turn;
            document.getElementById('obstacle-count').textContent = gameState.obstacleCount;
        }

        function updateClassInfo() {
            const player = players[gameState.currentPlayer];
            const className = gameState.playerClasses[player];
            const info = classInfo[className];
            const classInfoDiv = document.getElementById('class-info');
            classInfoDiv.innerHTML = `
                <h3 class="class-name ${className.toLowerCase()}">${className}</h3>
                <p class="class-description">${info.description}</p>
                <ul class="class-abilities">
                    ${info.abilities.map(ability => `
                        <li class="${ability.type === 'active' && gameState.usedAbilities[player]?.[ability.name] ? 'used' : ''} ${ability.type === 'active' && !gameState.usedAbilities[player]?.[ability.name] ? 'active-ability' : ''}" 
                            onclick="${ability.type === 'active' && !gameState.usedAbilities[player]?.[ability.name] ? `selectAbility('${ability.name}')` : ''}">
                            <strong>${ability.name}${ability.cost ? ` (${ability.cost} AP)` : ''}:</strong> ${ability.description}
                        </li>
                    `).join('')}
                </ul>
            `;
        }

        function selectAbility(abilityName) {
            const player = players[gameState.currentPlayer];
            if (confirm(`${abilityName} can only be used once per game. Are you sure?`)) {
                gameState.selectedAction = 'ability';
                if (abilityName === 'Hand Cannon' || abilityName === 'Rampage') {
                    executeAction(abilityName);
                } else {
                    renderGrid();
                }
            }
        }

        function showEliminationMessage(player) {
            const messageDiv = document.getElementById('elimination-message');
            messageDiv.textContent = `Player Eliminated! ${gameState.playerNames[player]} has been eliminated from the game.`;
            messageDiv.style.display = 'block';
            setTimeout(() => {
                messageDiv.style.display = 'none';
                checkGameState();
            }, 3000);
        }

        function showVictoryMessage(winner) {
            const messageDiv = document.getElementById('victory-message');
            messageDiv.innerHTML = `
                Victory! ${gameState.playerNames[winner]} Wins! All enemy Bloodwells destroyed.
                <button onclick="restartGame()">Restart Game</button>
            `;
            messageDiv.style.display = 'block';
        }

        function checkGameState() {
            const remainingPlayers = players.slice(0, gameState.playerCount).filter(p => gameState.bloodwells[p].length > 0);
            if (remainingPlayers.length === 1) {
                showVictoryMessage(remainingPlayers[0]);
            }
        }

        function restartGame() {
            document.getElementById('victory-message').style.display = 'none';
            document.getElementById('game-screen').style.display = 'none';
            document.getElementById('setup-screen').style.display = 'block';
            gameState = {
                currentPlayer: 0,
                turn: 1,
                ap: apPerTurn[1],
                playerCount: 2,
                guardians: {},
                bloodwells: {},
                obstacles: [],
                obstacleCount: 0,
                selectedGuardian: null,
                selectedAction: null,
                dreadFates: false,
                playerClasses: {},
                playerFates: {},
                cursed: {},
                usedAbilities: {},
                layout: null,
                playerNames: {},
                turnHistory: [],
                actionsThisTurn: []
            };
            initSetup();
        }

        window.onload = initSetup;
    </script>
</body>
</html>